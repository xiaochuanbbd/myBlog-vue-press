<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue面试题 | 晓川个人笔记</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="学习，复习 ，自用">
    
    <link rel="preload" href="/vue-press-blog/assets/css/0.styles.f743c302.css" as="style"><link rel="preload" href="/vue-press-blog/assets/js/app.af7be2e8.js" as="script"><link rel="preload" href="/vue-press-blog/assets/js/2.b3e5667e.js" as="script"><link rel="preload" href="/vue-press-blog/assets/js/18.a703fdb8.js" as="script"><link rel="prefetch" href="/vue-press-blog/assets/js/10.eeb372e5.js"><link rel="prefetch" href="/vue-press-blog/assets/js/11.bc41fd0c.js"><link rel="prefetch" href="/vue-press-blog/assets/js/12.94e8e147.js"><link rel="prefetch" href="/vue-press-blog/assets/js/13.913c2e2b.js"><link rel="prefetch" href="/vue-press-blog/assets/js/14.708062b0.js"><link rel="prefetch" href="/vue-press-blog/assets/js/15.5c240efd.js"><link rel="prefetch" href="/vue-press-blog/assets/js/16.ea6a7bb2.js"><link rel="prefetch" href="/vue-press-blog/assets/js/17.29a308e4.js"><link rel="prefetch" href="/vue-press-blog/assets/js/19.09081502.js"><link rel="prefetch" href="/vue-press-blog/assets/js/3.768ae9ff.js"><link rel="prefetch" href="/vue-press-blog/assets/js/4.cf7ad563.js"><link rel="prefetch" href="/vue-press-blog/assets/js/5.8365ead4.js"><link rel="prefetch" href="/vue-press-blog/assets/js/6.a7ab169c.js"><link rel="prefetch" href="/vue-press-blog/assets/js/7.6b34f241.js"><link rel="prefetch" href="/vue-press-blog/assets/js/8.216b22f6.js"><link rel="prefetch" href="/vue-press-blog/assets/js/9.db785850.js">
    <link rel="stylesheet" href="/vue-press-blog/assets/css/0.styles.f743c302.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vue-press-blog/" class="home-link router-link-active"><!----> <span class="site-name">晓川个人笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="vue Menu" class="dropdown-title"><span class="title">vue</span> <span class="arrow down"></span></button> <button type="button" aria-label="vue Menu" class="mobile-dropdown-title"><span class="title">vue</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue-press-blog/vue/vue2/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  vue2
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="javascript Menu" class="dropdown-title"><span class="title">javascript</span> <span class="arrow down"></span></button> <button type="button" aria-label="javascript Menu" class="mobile-dropdown-title"><span class="title">javascript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue-press-blog/javascript/js/" class="nav-link">
  js
</a></li><li class="dropdown-item"><!----> <a href="/vue-press-blog/javascript/dom/" class="nav-link">
  dom
</a></li><li class="dropdown-item"><!----> <a href="/vue-press-blog/javascript/event/" class="nav-link">
  事件
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="html css Menu" class="dropdown-title"><span class="title">css</span> <span class="arrow down"></span></button> <button type="button" aria-label="html css Menu" class="mobile-dropdown-title"><span class="title">css</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue-press-blog/css/css/" class="nav-link">
  css
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label=" other Menu" class="dropdown-title"><span class="title">杂项</span> <span class="arrow down"></span></button> <button type="button" aria-label=" other Menu" class="mobile-dropdown-title"><span class="title">杂项</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue-press-blog/other/webpack/" class="nav-link">
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/vue-press-blog/other/web/" class="nav-link">
  网络浏览器
</a></li><li class="dropdown-item"><!----> <a href="/vue-press-blog/other/optimization/" class="nav-link">
  性能优化
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label=" react Menu" class="dropdown-title"><span class="title">react</span> <span class="arrow down"></span></button> <button type="button" aria-label=" react Menu" class="mobile-dropdown-title"><span class="title">react</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue-press-blog/react/react/" class="nav-link">
  react
</a></li><li class="dropdown-item"><!----> <a href="/vue-press-blog/react/react-native/" class="nav-link">
  react-native
</a></li></ul></div></div> <a href="https://github.com/xiaochuanbbd/myBlog-vue-press" target="_blank" rel="noopener noreferrer" class="repo-link">
    查看源码
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="vue Menu" class="dropdown-title"><span class="title">vue</span> <span class="arrow down"></span></button> <button type="button" aria-label="vue Menu" class="mobile-dropdown-title"><span class="title">vue</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue-press-blog/vue/vue2/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  vue2
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="javascript Menu" class="dropdown-title"><span class="title">javascript</span> <span class="arrow down"></span></button> <button type="button" aria-label="javascript Menu" class="mobile-dropdown-title"><span class="title">javascript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue-press-blog/javascript/js/" class="nav-link">
  js
</a></li><li class="dropdown-item"><!----> <a href="/vue-press-blog/javascript/dom/" class="nav-link">
  dom
</a></li><li class="dropdown-item"><!----> <a href="/vue-press-blog/javascript/event/" class="nav-link">
  事件
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="html css Menu" class="dropdown-title"><span class="title">css</span> <span class="arrow down"></span></button> <button type="button" aria-label="html css Menu" class="mobile-dropdown-title"><span class="title">css</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue-press-blog/css/css/" class="nav-link">
  css
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label=" other Menu" class="dropdown-title"><span class="title">杂项</span> <span class="arrow down"></span></button> <button type="button" aria-label=" other Menu" class="mobile-dropdown-title"><span class="title">杂项</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue-press-blog/other/webpack/" class="nav-link">
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/vue-press-blog/other/web/" class="nav-link">
  网络浏览器
</a></li><li class="dropdown-item"><!----> <a href="/vue-press-blog/other/optimization/" class="nav-link">
  性能优化
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label=" react Menu" class="dropdown-title"><span class="title">react</span> <span class="arrow down"></span></button> <button type="button" aria-label=" react Menu" class="mobile-dropdown-title"><span class="title">react</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue-press-blog/react/react/" class="nav-link">
  react
</a></li><li class="dropdown-item"><!----> <a href="/vue-press-blog/react/react-native/" class="nav-link">
  react-native
</a></li></ul></div></div> <a href="https://github.com/xiaochuanbbd/myBlog-vue-press" target="_blank" rel="noopener noreferrer" class="repo-link">
    查看源码
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>vue面试题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-blog/vue/vue2/#v-show-v-if" class="sidebar-link">v-show  v-if</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#vif-优先级" class="sidebar-link">vif 优先级</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#vfor-循环对象" class="sidebar-link">vfor 循环对象</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#keepalive" class="sidebar-link">keepalive</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#事件target" class="sidebar-link">事件target</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#组件通信方法" class="sidebar-link">组件通信方法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#异步组件" class="sidebar-link">异步组件</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#组件缓存" class="sidebar-link">组件缓存</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#插槽的使用" class="sidebar-link">插槽的使用</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#mvvm-model-view-viewmodel" class="sidebar-link">MVVM model-view- viewModel</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#v-for中对key的理解" class="sidebar-link">v-for中对key的理解</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#vue原理" class="sidebar-link">vue原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-press-blog/vue/vue2/#vue2" class="sidebar-link">vue2</a></li><li class="sidebar-sub-header"><a href="/vue-press-blog/vue/vue2/#vue3" class="sidebar-link">Vue3</a></li></ul></li><li><a href="/vue-press-blog/vue/vue2/#diff算法原理" class="sidebar-link">diff算法原理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#vuex相关" class="sidebar-link">vuex相关</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-press-blog/vue/vue2/#其中仓库分为三个区域" class="sidebar-link">其中仓库分为三个区域：</a></li></ul></li><li><a href="/vue-press-blog/vue/vue2/#computed和watch的区别" class="sidebar-link">computed和watch的区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#为什么data是一个函数" class="sidebar-link">为什么data是一个函数</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#v-show是重排吗" class="sidebar-link">v-show是重排吗？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#为什么·不是用index或者随机数来进行key" class="sidebar-link">为什么·不是用index或者随机数来进行key</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#vue单项数据流" class="sidebar-link">vue单项数据流</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-press-blog/vue/vue2/#props" class="sidebar-link">Props:</a></li></ul></li><li><a href="/vue-press-blog/vue/vue2/#父子组件的生命周期执行顺序" class="sidebar-link">父子组件的生命周期执行顺序</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-press-blog/vue/vue2/#注意" class="sidebar-link">注意</a></li></ul></li><li><a href="/vue-press-blog/vue/vue2/#vue事件绑定原理" class="sidebar-link">vue事件绑定原理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#vue-router钩子函数-执行顺序" class="sidebar-link">vue-router钩子函数，执行顺序</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-press-blog/vue/vue2/#全局守卫" class="sidebar-link">全局守卫</a></li><li class="sidebar-sub-header"><a href="/vue-press-blog/vue/vue2/#路由守卫" class="sidebar-link">路由守卫，</a></li><li class="sidebar-sub-header"><a href="/vue-press-blog/vue/vue2/#组件守卫" class="sidebar-link">组件守卫</a></li><li class="sidebar-sub-header"><a href="/vue-press-blog/vue/vue2/#当点击切换路由时" class="sidebar-link">当点击切换路由时</a></li></ul></li><li><a href="/vue-press-blog/vue/vue2/#vue函数式组件" class="sidebar-link">vue函数式组件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-press-blog/vue/vue2/#函数式组件的优点" class="sidebar-link">函数式组件的优点</a></li></ul></li><li><a href="/vue-press-blog/vue/vue2/#vue性能优化" class="sidebar-link">vue性能优化</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#webpack层面优化" class="sidebar-link">webpack层面优化：</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#mixin混合使用场景和原理" class="sidebar-link">mixin混合使用场景和原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-press-blog/vue/vue2/#作用" class="sidebar-link">作用：</a></li><li class="sidebar-sub-header"><a href="/vue-press-blog/vue/vue2/#原理" class="sidebar-link">原理：</a></li></ul></li><li><a href="/vue-press-blog/vue/vue2/#vue-extend-作用及原理" class="sidebar-link">Vue.extend 作用及原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-press-blog/vue/vue2/#原理-2" class="sidebar-link">原理：</a></li><li class="sidebar-sub-header"><a href="/vue-press-blog/vue/vue2/#与mixin的区别" class="sidebar-link">与mixin的区别：</a></li></ul></li><li><a href="/vue-press-blog/vue/vue2/#双向数据绑定的原理-v-model" class="sidebar-link">双向数据绑定的原理 v-model</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#keepalive-2" class="sidebar-link">keepalive</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-press-blog/vue/vue2/#两个生命周期" class="sidebar-link">两个生命周期：</a></li><li class="sidebar-sub-header"><a href="/vue-press-blog/vue/vue2/#提供两个属性" class="sidebar-link">提供两个属性：</a></li><li class="sidebar-sub-header"><a href="/vue-press-blog/vue/vue2/#原理-3" class="sidebar-link">原理：</a></li></ul></li><li><a href="/vue-press-blog/vue/vue2/#vue-use-使用一个插件" class="sidebar-link">vue.use 使用一个插件</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#vue修饰符" class="sidebar-link">vue修饰符</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#nexttick原理" class="sidebar-link">nextTick原理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#vue模版编译原理" class="sidebar-link">vue模版编译原理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#vue指令的原理" class="sidebar-link">vue指令的原理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#vue-set-原理" class="sidebar-link">vue.$set（）原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-press-blog/vue/vue2/#vue-set-原理-2" class="sidebar-link">Vue.set()原理：</a></li></ul></li><li><a href="/vue-press-blog/vue/vue2/#vue-router" class="sidebar-link">vue-router</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-press-blog/vue/vue2/#hash模式" class="sidebar-link">hash模式</a></li><li class="sidebar-sub-header"><a href="/vue-press-blog/vue/vue2/#history模式" class="sidebar-link">history模式</a></li></ul></li><li><a href="/vue-press-blog/vue/vue2/#虚拟dom的优缺点缺点" class="sidebar-link">虚拟dom的优缺点缺点</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#diff算法" class="sidebar-link">diff算法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#key的作用" class="sidebar-link">key的作用</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#组件传递方式" class="sidebar-link">组件传递方式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-press-blog/vue/vue2/#父子" class="sidebar-link">父子：</a></li><li class="sidebar-sub-header"><a href="/vue-press-blog/vue/vue2/#祖孙" class="sidebar-link">祖孙：</a></li><li class="sidebar-sub-header"><a href="/vue-press-blog/vue/vue2/#兄弟" class="sidebar-link">兄弟</a></li></ul></li><li><a href="/vue-press-blog/vue/vue2/#v-html会造成什么问题" class="sidebar-link">v-html会造成什么问题</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#mvc-mvvm-区别" class="sidebar-link">mvc mvvm 区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#vue的内置指令" class="sidebar-link">vue的内置指令</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#虚拟dom的优缺点" class="sidebar-link">虚拟dom的优缺点：</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#数据响应式和双向数据绑定的区别" class="sidebar-link">数据响应式和双向数据绑定的区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#spa-单页面-的优缺点" class="sidebar-link">SPA（单页面）的优缺点：</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#为什么单页面首频加载慢" class="sidebar-link">为什么单页面首频加载慢？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/vue/vue2/#路由懒加载的几种方式" class="sidebar-link">路由懒加载的几种方式</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue面试题"><a href="#vue面试题" class="header-anchor">#</a> vue面试题</h1> <h2 id="v-show-v-if"><a href="#v-show-v-if" class="header-anchor">#</a> v-show  v-if</h2> <p>v-show是使用css中的display：none， v-if是对 Dom元素创建 ，元素频繁更改使用v-show，一次渲染使用dom</p> <h2 id="vif-优先级"><a href="#vif-优先级" class="header-anchor">#</a> vif 优先级</h2> <p>Vif 渲染的优先级高于 v for 不要一起连用，循环出来再去看vif，再隐藏 vif建议使用在父元素上面</p> <h2 id="vfor-循环对象"><a href="#vfor-循环对象" class="header-anchor">#</a> vfor 循环对象</h2> <p>v-for 可以使用对象进行循环 三个参数（value，key,index）</p> <h2 id="keepalive"><a href="#keepalive" class="header-anchor">#</a> keepalive</h2> <p>使用keep-alive可以在activated里执行原本在mounted的逻辑</p> <h2 id="事件target"><a href="#事件target" class="header-anchor">#</a> 事件target</h2> <p>事件对象@click=xxx（e）e.target为触发时间的元素</p> <h2 id="组件通信方法"><a href="#组件通信方法" class="header-anchor">#</a> 组件通信方法</h2> <ul><li>父子组件：props/$emit</li> <li>兄弟组件： eventBus 定义在vue的实例上，事件总线的方式 使用new Vue()实例上的$emits和$on 方法,这个需要在beforeDestory()钩子里面进行解绑</li></ul> <h2 id="异步组件"><a href="#异步组件" class="header-anchor">#</a> 异步组件</h2> <p>修改import引入为函数import引入 ：（）=》｛｝</p> <h2 id="组件缓存"><a href="#组件缓存" class="header-anchor">#</a> 组件缓存</h2> <p>keepalive 组件内容不多使用v-show也可以实现效果</p> <h2 id="插槽的使用"><a href="#插槽的使用" class="header-anchor">#</a> 插槽的使用</h2> <p>理解插槽：在子组件中站好了位置，使用该子组件是可以传递任意的内容给他，自动填坑，替换放置slot的位置
插槽的原理：slot本质是返回vnode函数</p> <ul><li>默认插槽： 子组件内定义一个<code>&lt;slot&gt;&lt;/slot&gt;</code>标签，父组件传入内容</li> <li>具名插槽：子组件内定义一个标签， 父组件通过 来填入东西。</li> <li>作用域插槽：子组件在组件内定义数据 父组件在子组件标签名上获取数据，使用插槽 内的数据</li> <li>作用域+具名插槽混合使用： 父组件 在template标签内将default替换为name属性绑定的</li></ul> <h2 id="mvvm-model-view-viewmodel"><a href="#mvvm-model-view-viewmodel" class="header-anchor">#</a> MVVM model-view- viewModel</h2> <p>即将数据模型与数据表现层通过数据驱动进行分离，只需要关心数据的开发，不需要考虑页面的展示</p> <ul><li>M是代表 model 模型 、操作数据和定义数据的模型</li> <li>V代表的是页面展示</li> <li>vm： 代表的是数据和页面之间的桥梁，通过双向数据绑定将数据与页面绑定起来，从而达到数据更新即更新页面的功
能。 这里的更新是同步操作的，无需人工干涉</li></ul> <h2 id="v-for中对key的理解"><a href="#v-for中对key的理解" class="header-anchor">#</a> v-for中对key的理解</h2> <p>key是为了更好的支持 diff算法，通过唯一标识对更新和删除的元素进行对比，更高效的操作虚拟dom</p> <h2 id="vue原理"><a href="#vue原理" class="header-anchor">#</a> vue原理</h2> <h3 id="vue2"><a href="#vue2" class="header-anchor">#</a> vue2</h3> <ul><li>通过数据劫持 结合发布者和订阅者模式，使用definedpro perty来劫持各个属性的getter和setter ，在数据更新的时候
发布消息给各个订阅者，出发相应的回调函数</li> <li>缺点： 需要递归对data中的复杂对象进行劫持， 删除和增加元素无法响应式，数组改变长度和通过下标修改也做不到。</li></ul> <h3 id="vue3"><a href="#vue3" class="header-anchor">#</a> Vue3</h3> <p>proxy vue3
采用新的proxy API es6里的方法
proxy可以劫持整个对象</p> <ul><li>reflect 劫持
1.多层代理，通过get方法来判断
好处：不会一上来就递归data数据，而是当获取这个属性时候的时候再去判断是不是对象 是对象里的属性在递归进行reflect劫持，</li> <li>weakmap（）
生成弱引用，解决proxy重复代理
缺点： 兼容性不好IE11不兼容</li> <li>Reflect ： 类似于Object对象，其中包括了object的静态函数，但reflect并不是一个函数对象，所以他是一个不可构造的</li></ul> <h2 id="diff算法原理"><a href="#diff算法原理" class="header-anchor">#</a> diff算法原理</h2> <ul><li>作用： 修改dom的一小部分，不会引起dom树的重绘和重排</li> <li>原理： diff算法将某个节点数据变化后生成新的vnode，将新的vnode与原来的节点使用patch函数进行对比，比较新旧
节点，并替换新旧节点，一边比较一边给真实dom打补丁进行替换</li></ul> <h2 id="vuex相关"><a href="#vuex相关" class="header-anchor">#</a> vuex相关</h2> <ul><li>vuex是一个用来集中管理数据的状态管理仓库</li></ul> <h3 id="其中仓库分为三个区域"><a href="#其中仓库分为三个区域" class="header-anchor">#</a> 其中仓库分为三个区域：</h3> <ul><li><p>status：用来存放数据处 响应式数据</p></li> <li><p>Mutations:存放同步代码，并且将数据传给status修改status的地方
vuex里使用commit触发，组件内使用this.$store.commit（’xxx’）/…mapMutation(‘xxx’,参数)</p></li> <li><p>actions：用来存放异步代码，并且调用异步方法的地方
触发mutation函数，在组件内触发可以使用this.$store.dispatch（’方法名’）/ …mapAction(‘xxx’,参
数)</p></li> <li><p>getters：需要从store里的status里派生一些状态，比如对列表进行过滤或者计数等，可以理解为status的计算属性
组件内取出数据：…mapGetters([‘xxx’,’xxx’])</p></li> <li><p>Namespace:分模块管理
给模块添加namespace：true的方式使其成为带命名空间的模块
在根store文件内引入模块并且挂载
组件内读取</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code>state：$store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>userInfo<span class="token punctuation">.</span>userName
mutation：<span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">&quot;userInfo/setUserInfo&quot;</span><span class="token punctuation">,</span>userInfo<span class="token punctuation">)</span>
<span class="token literal-property property">action</span><span class="token operator">:</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'moduleB/moduleBAction'</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token literal-property property">root</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token literal-property property">Getters</span><span class="token operator">:</span><span class="token function">…mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">[</span>‘模块名<span class="token operator">/</span>getter名’<span class="token punctuation">]</span><span class="token punctuation">)</span>
require<span class="token punctuation">.</span><span class="token function">context</span><span class="token punctuation">(</span> <span class="token punctuation">)</span>
webpackAPI 自动化倒入模块

</code></pre></div><h2 id="computed和watch的区别"><a href="#computed和watch的区别" class="header-anchor">#</a> computed和watch的区别</h2> <p>computed是计算属性，是根据已有的数据去进行一些计算得出一个新的数据，不支持异步和缓存，如果这个属性的属性值是一个函数
watch是属于监视现有的数据，监视他的变化 immediate：true. 是否立即触发，deep:true是否深度监视,监听对象内部</p> <h2 id="为什么data是一个函数"><a href="#为什么data是一个函数" class="header-anchor">#</a> 为什么data是一个函数</h2> <p>data一般是出现在组件当中， 组件是可以被复用的，js里的对象是引用关系， 如果data是一个对象，那么组件间的data
对象会相互污染，
如果是一个函数的话，会起到隔离变量的作用</p> <h2 id="v-show是重排吗"><a href="#v-show是重排吗" class="header-anchor">#</a> v-show是重排吗？</h2> <p>是，重排的定义是渲染树中的节点信息发生了大小/边距等改变，要重新计算节点css的大小和位置
因为vshow是使用的display进行元素的控制 ，会改变节点的大小和渲染树的布局 导致重排</p> <h2 id="为什么·不是用index或者随机数来进行key"><a href="#为什么·不是用index或者随机数来进行key" class="header-anchor">#</a> 为什么·不是用index或者随机数来进行key</h2> <p>在插入或者删除的时候，key会导致绑定的index变化从而需要重新渲染，效率低。会导致性能浪费，使用index渲染key
可能会出错</p> <h2 id="vue单项数据流"><a href="#vue单项数据流" class="header-anchor">#</a> vue单项数据流</h2> <h3 id="props"><a href="#props" class="header-anchor">#</a> Props:</h3> <p>数据从父组件传递给子组件，数据只能在父组件内进行修改，子组件无法进行修改。
如何操作数据：</p> <ul><li>使用$emit去触发父组件中的函数对数据进行修改。</li> <li>子组件的data新定一个值获取props，用这个去改变；</li> <li>使用.sync修饰符</li></ul> <h2 id="父子组件的生命周期执行顺序"><a href="#父子组件的生命周期执行顺序" class="header-anchor">#</a> 父子组件的生命周期执行顺序</h2> <ul><li>父 beforeCreate</li> <li>父 created</li> <li>子 beforeCreate</li> <li>子 created</li> <li>子 mounted</li> <li>父 mounted</li> <li>父 beforeDestroy</li> <li>子 beforeDestroy</li> <li>子 destroyed</li> <li>父 destroyed</li></ul> <h3 id="注意"><a href="#注意" class="header-anchor">#</a> 注意</h3> <ul><li>create创建实例对象是先父后子</li> <li>beforeDestroy是先父后子</li> <li>父组件里的更新触及到子组件的更新是先父后子</li> <li>mounted挂载dom是先子后父</li> <li>destroy组件消亡是先子后父</li></ul> <h2 id="vue事件绑定原理"><a href="#vue事件绑定原理" class="header-anchor">#</a> vue事件绑定原理</h2> <p>原生时间是通过addEventListener
组件上的事件是通过$on修饰符， 如果想添加原生时间需要➕.native。将其绑定在子元素html元素上，变成原生事件</p> <h2 id="vue-router钩子函数-执行顺序"><a href="#vue-router钩子函数-执行顺序" class="header-anchor">#</a> vue-router钩子函数，执行顺序</h2> <h3 id="全局守卫"><a href="#全局守卫" class="header-anchor">#</a> 全局守卫</h3> <ul><li>beforeEach 每次路由进入前执行的函数</li> <li>afterEach 每次路由进入之后执行的函数</li> <li>beforeResolve 全局解析守卫</li></ul> <h3 id="路由守卫"><a href="#路由守卫" class="header-anchor">#</a> 路由守卫，</h3> <ul><li>beforeEnter 指定路由进入前的函数</li> <li>beforeLeave 指定路由离开前的函数</li></ul> <h3 id="组件守卫"><a href="#组件守卫" class="header-anchor">#</a> 组件守卫</h3> <ul><li>beforeRouterEnter 组件内路由进入前的函数</li> <li>beforeRouterLeave 组件内路由离开前的函数</li> <li>beforeRouterUpdate 组件内路由更新的函数</li></ul> <h3 id="当点击切换路由时"><a href="#当点击切换路由时" class="header-anchor">#</a> 当点击切换路由时</h3> <p>beforeRouterLeave=&gt;beforeEach=&gt;beforeEnter=&gt;beforeRouteEnter=&gt;beforeResolve=&gt;afterEach=&gt;beforeRouteEnter</p> <h2 id="vue函数式组件"><a href="#vue函数式组件" class="header-anchor">#</a> vue函数式组件</h2> <ul><li>开启方式：functional:true</li> <li>不需要实例化，函数组件没有this，this死通过render函数的第二个参数context来代替的</li> <li>没有生命周期。不能使用计算属性watch。</li> <li>不能同$emit暴露事件，调用时间只能通过context.listeners.click的方式调用外部传入的事件</li></ul> <h3 id="函数式组件的优点"><a href="#函数式组件的优点" class="header-anchor">#</a> 函数式组件的优点</h3> <ul><li>不需要实例化，无状态，没有生命周期，渲染性能要好于普通组件</li> <li>结构比较简单，代码比较清晰</li></ul> <h2 id="vue性能优化"><a href="#vue性能优化" class="header-anchor">#</a> vue性能优化</h2> <ul><li>响应式数据不需要使用的只做为展示的，可以使用object.freeze（）进行冻结</li> <li>合理使用v-if v-show。频繁切换用v-show 不频繁使用v-if</li> <li>v-for遍历少使用index，最好使用id值</li> <li>大数据列表使用虚拟列表，虚拟表格</li> <li>组件销毁后要把全局变量和实践销毁</li> <li>图片懒加载，路由懒加载</li> <li>第三方插件比如element-UI 按需引入</li> <li>适当采用keepalive缓存组件</li> <li>防抖节流用起来</li> <li>服务端渲染ssr, 预渲染</li></ul> <h2 id="webpack层面优化"><a href="#webpack层面优化" class="header-anchor">#</a> webpack层面优化：</h2> <ul><li>对图片进行压缩</li> <li>提取公共代码 commonsChunkPlugin</li> <li>提取组件css</li> <li>优化sourceMap</li> <li>构建结果输出分析，利webpack-bundle-analyzer</li> <li>打包优化</li> <li>压缩代码</li> <li>treeshaking</li> <li>seo优化</li> <li>预渲染</li> <li>服务端渲染 SSR</li> <li>Happypack 多线程打包</li> <li>抽离公共组件</li> <li>soureMap优化</li> <li>Vue 的SPA页面如何优化加载速度</li> <li>减少入口文件体积</li> <li>静态资源本地缓存</li> <li>开启GZIP压缩</li> <li>使用SSR.nuxt.js</li></ul> <h2 id="mixin混合使用场景和原理"><a href="#mixin混合使用场景和原理" class="header-anchor">#</a> mixin混合使用场景和原理</h2> <h3 id="作用"><a href="#作用" class="header-anchor">#</a> 作用：</h3> <p>分发vue组件中可服用的功能，提取相似代码</p> <h3 id="原理"><a href="#原理" class="header-anchor">#</a> 原理：</h3> <p>merOptions,类似于对象的继承，当组件初始化的时候会调用mergeOptions方法进行合并。当组件和混入对象含有相同名选项时，以恰当的方式进</p> <h4 id="mergeoptions方法"><a href="#mergeoptions方法" class="header-anchor">#</a> mergeOptions方法：</h4> <p>步骤：
先递归处理mixin，合并parent中的key,调用mergeField方法进行合并，保存在变量options中，在遍历child，不上parent中没有的key，
调用mergefield方法进行合并，并保存变量在options中，最后将options返回</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">mergeOptions</span> <span class="token punctuation">(</span>
<span class="token parameter"><span class="token literal-property property">parent</span><span class="token operator">:</span> Object<span class="token punctuation">,</span>
<span class="token literal-property property">child</span><span class="token operator">:</span> Object<span class="token punctuation">,</span>
vm<span class="token operator">?</span><span class="token operator">:</span> Component</span>
<span class="token punctuation">)</span><span class="token operator">:</span> Object <span class="token punctuation">{</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>mixins<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 判断有没有mixin 有的话递归进行合并</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> child<span class="token punctuation">.</span>mixins<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
parent <span class="token operator">=</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> child<span class="token punctuation">.</span>mixins<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> key
<span class="token keyword">for</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token function">mergeField</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token comment">// 先遍历parent的key</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> child<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasOwn</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果parent已经处理过某个key 就不处理了</span>
<span class="token function">mergeField</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token comment">// 处理child中的key 也就parent中没有处理过的key</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">mergeField</span> <span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">const</span> strat <span class="token operator">=</span> strats<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">||</span> defaultStrat
options<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">strat</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> child<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> vm<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token comment">// 根据不同类型的options调用strats中不同的方法进行合并</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> options
<span class="token punctuation">}</span>
</code></pre></div><h2 id="vue-extend-作用及原理"><a href="#vue-extend-作用及原理" class="header-anchor">#</a> Vue.extend 作用及原理</h2> <p>使用Vue基础构造器，创建一个子类，参数是一个包涵组件选项的对象,该方法返回一个与Vue具有相同功能的构造函数</p> <h3 id="原理-2"><a href="#原理-2" class="header-anchor">#</a> 原理：</h3> <p>核心思路是新建一个VueCommponent构造函数，命名为sub,通过将VueCommponent的原型指向Vue的构造函数的原型方式继承Vue构造函数上所有</p> <div class="language-js extra-class"><pre class="language-js"><code>Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
Suber <span class="token operator">=</span> <span class="token keyword">this</span>
VueCommponent<span class="token punctuation">.</span>protoType <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Super</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="与mixin的区别"><a href="#与mixin的区别" class="header-anchor">#</a> 与mixin的区别：</h3> <p>mixin是对vue options进行混入，所有的vue实例对象都会具备混入进来的配置行为
extend是产生一个继承自Vue类的子类，只会影响这个子类的实例对象，不会对vue类本身以及Vue类的实例对象产生影响</p> <div class="language-js extra-class"><pre class="language-js"><code>简单创造一个子类
<span class="token comment">// 创建构造器。js文件</span>
<span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">var</span> Profile <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
<span class="token literal-property property">template</span><span class="token operator">:</span> <span class="token string">'&lt;p v-on:click=&quot;workclick&quot;&gt;{{firstName}} {{lastName}} aka {{alias}}111111&lt;/p&gt;'</span><span class="token punctuation">,</span>
<span class="token function-variable function">data</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">return</span> <span class="token punctuation">{</span>
<span class="token literal-property property">firstName</span><span class="token operator">:</span> <span class="token string">'Walter'</span><span class="token punctuation">,</span>
<span class="token literal-property property">lastName</span><span class="token operator">:</span> <span class="token string">'White'</span><span class="token punctuation">,</span>
<span class="token literal-property property">alias</span><span class="token operator">:</span> <span class="token string">'Heisenberg'</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token literal-property property">methods</span><span class="token operator">:</span><span class="token punctuation">{</span>
<span class="token function">workclick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'我执行了'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> Profile
组件内应用：
<span class="token keyword">import</span> Profile <span class="token keyword">from</span> '@<span class="token operator">/</span>components<span class="token operator">/</span>Exetend’
<span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token keyword">new</span> <span class="token class-name">Profile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">'#mount-point'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="双向数据绑定的原理-v-model"><a href="#双向数据绑定的原理-v-model" class="header-anchor">#</a> 双向数据绑定的原理 v-model</h2> <p>v-model本质是语法糖，v-model在内部为不同的输入元素使用不同的属性抛出不同的事件
input+textarea：value：data里的值， 触发事件： input = $event.target.value
Checkbox+radio 使用checked和change事件
select采用 prop和change事件</p> <h2 id="keepalive-2"><a href="#keepalive-2" class="header-anchor">#</a> keepalive</h2> <p>https://segmentfault.com/a/1190000011978825</p> <p>缓存组件的功能。避免多次加载相应的组件，消耗性能，能够将不活动的组件，保存在内存中， 而不是直接销毁，是一个抽象组件，不会渲染到</p> <h3 id="两个生命周期"><a href="#两个生命周期" class="header-anchor">#</a> 两个生命周期：</h3> <ul><li>Activated :激活的时候调用</li> <li>Deactivated：停用时调用</li></ul> <h3 id="提供两个属性"><a href="#提供两个属性" class="header-anchor">#</a> 提供两个属性：</h3> <ul><li>include：需要缓存的组件</li> <li>exclude：不需要缓存的组件</li></ul> <h3 id="原理-3"><a href="#原理-3" class="header-anchor">#</a> 原理：</h3> <p>运用LRU原理
选择最近最久未使用的组件予以淘汰。</p> <h4 id="lru算法"><a href="#lru算法" class="header-anchor">#</a> LRU算法：</h4> <p>最新数据插入数组末尾，命中缓存的数据也插入到数组末尾，当数组满了，删除头部的数据。</p> <p>kee-alive的缓存，是基于VNode节点而不是直接储存dom结构，本质是将需要缓存的VNode缓存在this.catch中，在render的时候如果VNode的name符合在缓存条件（include和exclude）。则会从this.catch中取出之前的VNode实例进行渲染
缓存在creaeted钩子创建一个缓存容器。保存Vnode节点，在destoryed组件中进行销毁组件实例 ，watch对include和exclude进行监视，被修改的时候对cache进行修正。render对vnode进行节点的缓存</p> <h2 id="vue-use-使用一个插件"><a href="#vue-use-使用一个插件" class="header-anchor">#</a> vue.use 使用一个插件</h2> <p>https://www.jianshu.com/p/0b8b6f2e5a82
https://blog.csdn.net/ZYS10000/article/details/107246076/
使用时必须传入一个Objecthuo或者Fuction，如果是Object必须有install对象，如果是函数，那么这个函数会被当成是install方法。
当Vue.ues执行的时候，第一个参数是vue,其他参数是vue.use执行的其他参数
当使用Vue.use()的时候会默认执行install方法。
简单使用：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App.vue'</span>
<span class="token keyword">const</span> plugn <span class="token operator">=</span> <span class="token punctuation">{</span>
<span class="token function">install</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>plugn<span class="token punctuation">)</span>
</code></pre></div><h2 id="vue修饰符"><a href="#vue修饰符" class="header-anchor">#</a> vue修饰符</h2> <p>.stop 阻止事件冒泡
Prevent 阻止事件默认行为
once 只触发一次
Self 只有触发自己的事件时才会执行</p> <h2 id="nexttick原理"><a href="#nexttick原理" class="header-anchor">#</a> nextTick原理</h2> <p>理解：主要是思路是采用微任务优先的方式调用异步方法去执行nextTick包装的方法。
使用顺序：</p> <ul><li>promise.then</li> <li>mutationObserver</li> <li>setImmediate setTimeout
mutationObserver：监听dom变化</li></ul> <h2 id="vue模版编译原理"><a href="#vue模版编译原理" class="header-anchor">#</a> vue模版编译原理</h2> <p>简单：</p> <ul><li>vue模版编译的原理就是将template转化为render函数的过程
阶段：https://segmentfault.com/a/1190000013763590</li> <li>生成AST树 (解析器)（抽象语法树（AST） https://blog.csdn.net/huangpb123/article/details/84799198
优化 （优化器）
codegen（代码生成器）</li></ul> <ol><li>将模版字符串转换为element ASTs (解析器)</li> <li>递归对AST进行静态节点标记，主要用来做虚拟DOM的渲染优化（优化器）
静态节点主要是指那些不需要发生变化的dom节点，包括静态节点和静态根结点（里面的子元素都是静态节点）。比如纯文本，&lt; p&gt;我是静态节
静态节点标注好处：dom更新时可以被跳过，更新时不需要为其创建新节点</li> <li>使用element ASTs 生成render函数代码字符串 （代码生成器）</li></ol> <h2 id="vue指令的原理"><a href="#vue指令的原理" class="header-anchor">#</a> vue指令的原理</h2> <p>1、在生成ast语法树的时候，遇到指令会给当前的元素添加directives属性；
2、通过 genDirectives 生成指令代码
3、在 patch 前将指令的钩子提取到 cbs 中，在 patch 过程中调用对应的钩子。
4、当执行指令对应钩子函数时，调用对应指令定义方法。</p> <h2 id="vue-set-原理"><a href="#vue-set-原理" class="header-anchor">#</a> vue.$set（）原理</h2> <p>Vue响应式原理两种情况修改vue不会触发视图的更新：</p> <ol><li>新增一个对象内的响应式数据</li> <li>更改数组下标来修改数组的值</li></ol> <h3 id="vue-set-原理-2"><a href="#vue-set-原理-2" class="header-anchor">#</a> Vue.set()原理：</h3> <p>响应式数据，会给对象和数组本身新增__ob__属性，代表的是Observer实例，当给对象新增不存在的属性时，$set（）首先会把新的属性进行响应式跟踪，然后后触发对象__ob__的dep收集到的watcher去更新，修改数组索引时我们调用数组本身的splice方法去更新数组</p> <h2 id="vue-router"><a href="#vue-router" class="header-anchor">#</a> vue-router</h2> <p>模式前端路由存在的意义： 改变视图的同时不会向后端发出请求</p> <h3 id="hash模式"><a href="#hash模式" class="header-anchor">#</a> hash模式</h3> <p>原理： onhashchange事件，可以在window上监听这个事件
特点：</p> <ul><li>有#号</li> <li>不会向服务端发起请求。改变hash不会重新加载页面</li></ul> <h3 id="history模式"><a href="#history模式" class="header-anchor">#</a> history模式</h3> <p>h5新增的pushStatus ()和replaceStatus()方法</p> <h4 id="刷新会-404"><a href="#刷新会-404" class="header-anchor">#</a> 刷新会 404</h4> <p>因为刷新会重新请求服务器 ，后台需要配置重定向到index.HTML页面（后端或者Nginx中进行简单配置）</p> <h2 id="虚拟dom的优缺点缺点"><a href="#虚拟dom的优缺点缺点" class="header-anchor">#</a> 虚拟dom的优缺点缺点</h2> <p>首次大量渲染dom时， 多了一层虚拟dom的计算，回避innerHTML插入慢
好处：</p> <ul><li>减少了dom操作，减少了重绘和回流</li> <li>保证性能下限，虽然不是最佳的性能，但具备局部更新的能力，比直接操作dom性能高</li></ul> <h2 id="diff算法"><a href="#diff算法" class="header-anchor">#</a> diff算法</h2> <p>当需要更新dom的时候，将需要更新的dom生成新的VNode，再将新的VNode和旧的VNode通过patch函数进行对比，更新并替换新旧VNode，并对真实dom打补丁操作</p> <h2 id="key的作用"><a href="#key的作用" class="header-anchor">#</a> key的作用</h2> <p>主要应用于虚拟dom中，vue通过对比新旧节点的key，来判断节点是否改变，用key可以提高渲染效率，更搞笑的操作虚拟dom</p> <h2 id="组件传递方式"><a href="#组件传递方式" class="header-anchor">#</a> 组件传递方式</h2> <h3 id="父子"><a href="#父子" class="header-anchor">#</a> 父子：</h3> <ul><li>props</li> <li>$attrs $listenners</li> <li>$children $parent</li> <li>$refs</li> <li>slot-scope 父组件享受子组件的作用域</li> <li>.sync</li></ul> <h3 id="祖孙"><a href="#祖孙" class="header-anchor">#</a> 祖孙：</h3> <ul><li>provide inject</li></ul> <h3 id="兄弟"><a href="#兄弟" class="header-anchor">#</a> 兄弟</h3> <ul><li>eventBUS</li> <li>$emit 触发事件</li> <li>$on 绑定事件函数</li> <li>vuex</li></ul> <h2 id="v-html会造成什么问题"><a href="#v-html会造成什么问题" class="header-anchor">#</a> v-html会造成什么问题</h2> <p>可能会造成xss（跨站脚本攻击，攻击者嵌入恶意脚本代码到正常用户会访问的页面中）攻击
v-html会替换掉子标签</p> <h2 id="mvc-mvvm-区别"><a href="#mvc-mvvm-区别" class="header-anchor">#</a> mvc mvvm 区别</h2> <ul><li>mvc思想：
一句话描述就是controller负责将数据用view显示出来。controller将model的数据赋值给了view</li> <li>mvvm:
通过vm做了数据绑定，将模型转换为视图，将视图转换为模型（实现方式：dom事件监听）</li> <li>区别：
实现了view和model的自动同步，当model属性改变时，不用再手动操作dom元素来改变view的展示，而是改变数据之后对于的view会自动改变。</li></ul> <h2 id="vue的内置指令"><a href="#vue的内置指令" class="header-anchor">#</a> vue的内置指令</h2> <ul><li><p>v-once: 定义他的元素或者组件只渲染一次，包括元素或组件的所有子节点，首次渲染后不再随数据的变化重新渲染，被视为静态内容</p></li> <li><p>v-cloak :保持在元素上直到关联实例结束编译，解决初始化慢导致页面闪动最佳实践</p></li> <li><p>v-bind： 动态更新html伤的元素属性</p></li> <li><p>v-on： 监听dom事件</p></li> <li><p>v-html：赋值变量给html 注意xss攻击</p></li> <li><p>v-text：更新元素的textContent</p></li> <li><p>v-model:ni</p></li> <li><p>v-if/v-else-if/v-else： 判断</p></li> <li><p>v-show：元素的显示隐藏 display</p></li> <li><p>v-for：循环指令</p></li> <li><p>v-pre： 跳过这个元素以及子元素的编译过程，以此来加快整个项目的编译速度</p></li></ul> <h2 id="虚拟dom的优缺点"><a href="#虚拟dom的优缺点" class="header-anchor">#</a> 虚拟dom的优缺点：</h2> <p>为什么用虚拟dom: 在浏览器中操作dom是很昂贵的，频繁操作dom，会产生一定的性能问题，这就是虚拟dom的产生原因，vue2借助了snabbdom的实现，用一个js对象去描述dom
是对真实dom的一种抽象
优点：
*.保证性能的下线,比直接粗暴的操作dom性能要好得多</p> <ul><li>无需手动操作dom 框架会根据虚拟dom和数据双向绑定，帮助我们更新视图</li> <li>跨平台。虚拟dom本质是JavaScript对象，虚拟dom可以更加方便的进行跨平台操作，例如服务端渲染等
缺点：</li> <li>无法进行极致优化，</li> <li>首次渲染，由于有多一层的diff算法，所以会比innerHTML插入要慢</li></ul> <h2 id="数据响应式和双向数据绑定的区别"><a href="#数据响应式和双向数据绑定的区别" class="header-anchor">#</a> 数据响应式和双向数据绑定的区别</h2> <p>响应式原理：单向数据 数据流向视图，通过object。definePropety()
双向数据绑定：通过value和绑定的事件去修改value值来修改的</p> <h2 id="spa-单页面-的优缺点"><a href="#spa-单页面-的优缺点" class="header-anchor">#</a> SPA（单页面）的优缺点：</h2> <p>优点：</p> <ol><li>加载快，用户感觉不到，交互体验好</li> <li>前后端分离 ，不需要请求服务器就可以刷新数据</li> <li>减轻服务器压力
缺点：
1.不利于seo优化
2.首屏加载慢
3.不适合大型开发项目</li></ol> <h2 id="为什么单页面首频加载慢"><a href="#为什么单页面首频加载慢" class="header-anchor">#</a> 为什么单页面首频加载慢？</h2> <p>因为第一次要把所有的页面组件内容下载下来
解决方案：</p> <ol><li>懒加载，通过脚手架配置
将每个文件打包成独立的文件， 首频加载的时候只加载首屏的文件， 点击其他页面再去加载其他页面的文件</li> <li>异步延迟加载
打包时，每个文件单独打包， 首屏加载时只加载第一个组件内容，后续组件异步加载（底层程序）</li> <li>静态资源本地缓存
4.图片资源 压缩
5.GZIP压缩</li> <li>使用ssr 客户端渲染 我们用的就是这个 nuxt.js
7.ui组件库按需加载
8.减少入口文件体积 treeshaking</li></ol> <h2 id="路由懒加载的几种方式"><a href="#路由懒加载的几种方式" class="header-anchor">#</a> 路由懒加载的几种方式</h2> <p>1.vue异步组件：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">component</span><span class="token operator">:</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span>@<span class="token operator">/</span>xxx<span class="token operator">/</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span>resolve<span class="token punctuation">)</span>
</code></pre></div><p>2.路由懒加载 import（）函数</p> <div class="language-js extra-class"><pre class="language-js"><code>componen
<span class="token keyword">const</span> <span class="token function-variable function">Home</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token keyword">import</span><span class="token punctuation">(</span>webpackChunkName<span class="token operator">:</span>xxx<span class="token punctuation">,</span><span class="token string">'@/component/index.js'</span><span class="token punctuation">)</span>
</code></pre></div><p>这里可以配置webpackchunkName 将文件打包到一个js文件
3.webpack提供的require.ensure()</p> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token punctuation">{</span>
<span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'/home'</span><span class="token punctuation">,</span>
<span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'home'</span><span class="token punctuation">,</span>
<span class="token function-variable function">component</span><span class="token operator">:</span><span class="token parameter">r</span><span class="token operator">=&gt;</span>require<span class="token punctuation">.</span><span class="token function">ensure</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token function">r</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@/components/index'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'demo'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/xiaochuanbbd/myBlog-vue-press/edit/master/vue/vue2/README.md" target="_blank" rel="noopener noreferrer">帮助我们改善此页面！</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">最后更新时间:</span> <span class="time">6/5/2022, 4:28:29 PM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/vue-press-blog/assets/js/app.af7be2e8.js" defer></script><script src="/vue-press-blog/assets/js/2.b3e5667e.js" defer></script><script src="/vue-press-blog/assets/js/18.a703fdb8.js" defer></script>
  </body>
</html>
