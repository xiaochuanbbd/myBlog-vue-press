<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>react特点 | 晓川个人笔记</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="学习，复习 ，自用">
    
    <link rel="preload" href="/vue-press-blog/assets/css/0.styles.f743c302.css" as="style"><link rel="preload" href="/vue-press-blog/assets/js/app.af7be2e8.js" as="script"><link rel="preload" href="/vue-press-blog/assets/js/2.b3e5667e.js" as="script"><link rel="preload" href="/vue-press-blog/assets/js/17.29a308e4.js" as="script"><link rel="prefetch" href="/vue-press-blog/assets/js/10.eeb372e5.js"><link rel="prefetch" href="/vue-press-blog/assets/js/11.bc41fd0c.js"><link rel="prefetch" href="/vue-press-blog/assets/js/12.94e8e147.js"><link rel="prefetch" href="/vue-press-blog/assets/js/13.913c2e2b.js"><link rel="prefetch" href="/vue-press-blog/assets/js/14.708062b0.js"><link rel="prefetch" href="/vue-press-blog/assets/js/15.5c240efd.js"><link rel="prefetch" href="/vue-press-blog/assets/js/16.ea6a7bb2.js"><link rel="prefetch" href="/vue-press-blog/assets/js/18.a703fdb8.js"><link rel="prefetch" href="/vue-press-blog/assets/js/19.09081502.js"><link rel="prefetch" href="/vue-press-blog/assets/js/3.768ae9ff.js"><link rel="prefetch" href="/vue-press-blog/assets/js/4.cf7ad563.js"><link rel="prefetch" href="/vue-press-blog/assets/js/5.8365ead4.js"><link rel="prefetch" href="/vue-press-blog/assets/js/6.a7ab169c.js"><link rel="prefetch" href="/vue-press-blog/assets/js/7.6b34f241.js"><link rel="prefetch" href="/vue-press-blog/assets/js/8.216b22f6.js"><link rel="prefetch" href="/vue-press-blog/assets/js/9.db785850.js">
    <link rel="stylesheet" href="/vue-press-blog/assets/css/0.styles.f743c302.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vue-press-blog/" class="home-link router-link-active"><!----> <span class="site-name">晓川个人笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="vue Menu" class="dropdown-title"><span class="title">vue</span> <span class="arrow down"></span></button> <button type="button" aria-label="vue Menu" class="mobile-dropdown-title"><span class="title">vue</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue-press-blog/vue/vue2/" class="nav-link">
  vue2
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="javascript Menu" class="dropdown-title"><span class="title">javascript</span> <span class="arrow down"></span></button> <button type="button" aria-label="javascript Menu" class="mobile-dropdown-title"><span class="title">javascript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue-press-blog/javascript/js/" class="nav-link">
  js
</a></li><li class="dropdown-item"><!----> <a href="/vue-press-blog/javascript/dom/" class="nav-link">
  dom
</a></li><li class="dropdown-item"><!----> <a href="/vue-press-blog/javascript/event/" class="nav-link">
  事件
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="html css Menu" class="dropdown-title"><span class="title">css</span> <span class="arrow down"></span></button> <button type="button" aria-label="html css Menu" class="mobile-dropdown-title"><span class="title">css</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue-press-blog/css/css/" class="nav-link">
  css
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label=" other Menu" class="dropdown-title"><span class="title">杂项</span> <span class="arrow down"></span></button> <button type="button" aria-label=" other Menu" class="mobile-dropdown-title"><span class="title">杂项</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue-press-blog/other/webpack/" class="nav-link">
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/vue-press-blog/other/web/" class="nav-link">
  网络浏览器
</a></li><li class="dropdown-item"><!----> <a href="/vue-press-blog/other/optimization/" class="nav-link">
  性能优化
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label=" react Menu" class="dropdown-title"><span class="title">react</span> <span class="arrow down"></span></button> <button type="button" aria-label=" react Menu" class="mobile-dropdown-title"><span class="title">react</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue-press-blog/react/react/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  react
</a></li><li class="dropdown-item"><!----> <a href="/vue-press-blog/react/react-native/" class="nav-link">
  react-native
</a></li></ul></div></div> <a href="https://github.com/xiaochuanbbd/myBlog-vue-press" target="_blank" rel="noopener noreferrer" class="repo-link">
    查看源码
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="vue Menu" class="dropdown-title"><span class="title">vue</span> <span class="arrow down"></span></button> <button type="button" aria-label="vue Menu" class="mobile-dropdown-title"><span class="title">vue</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue-press-blog/vue/vue2/" class="nav-link">
  vue2
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="javascript Menu" class="dropdown-title"><span class="title">javascript</span> <span class="arrow down"></span></button> <button type="button" aria-label="javascript Menu" class="mobile-dropdown-title"><span class="title">javascript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue-press-blog/javascript/js/" class="nav-link">
  js
</a></li><li class="dropdown-item"><!----> <a href="/vue-press-blog/javascript/dom/" class="nav-link">
  dom
</a></li><li class="dropdown-item"><!----> <a href="/vue-press-blog/javascript/event/" class="nav-link">
  事件
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="html css Menu" class="dropdown-title"><span class="title">css</span> <span class="arrow down"></span></button> <button type="button" aria-label="html css Menu" class="mobile-dropdown-title"><span class="title">css</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue-press-blog/css/css/" class="nav-link">
  css
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label=" other Menu" class="dropdown-title"><span class="title">杂项</span> <span class="arrow down"></span></button> <button type="button" aria-label=" other Menu" class="mobile-dropdown-title"><span class="title">杂项</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue-press-blog/other/webpack/" class="nav-link">
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/vue-press-blog/other/web/" class="nav-link">
  网络浏览器
</a></li><li class="dropdown-item"><!----> <a href="/vue-press-blog/other/optimization/" class="nav-link">
  性能优化
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label=" react Menu" class="dropdown-title"><span class="title">react</span> <span class="arrow down"></span></button> <button type="button" aria-label=" react Menu" class="mobile-dropdown-title"><span class="title">react</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue-press-blog/react/react/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  react
</a></li><li class="dropdown-item"><!----> <a href="/vue-press-blog/react/react-native/" class="nav-link">
  react-native
</a></li></ul></div></div> <a href="https://github.com/xiaochuanbbd/myBlog-vue-press" target="_blank" rel="noopener noreferrer" class="repo-link">
    查看源码
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>react特点</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-blog/react/react/#react特点" class="sidebar-link">react特点</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/react/react/#react核心文件" class="sidebar-link">react核心文件</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/react/react/#hello-world" class="sidebar-link">hello world</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/react/react/#虚拟dom" class="sidebar-link">虚拟dom</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/react/react/#jsx语法规则" class="sidebar-link">jsx语法规则</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/react/react/#react-18-更新-reactdom-render-以后绑定dom" class="sidebar-link">react 18 更新 ReactDOM.render，以后绑定dom</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/react/react/#react定义组件" class="sidebar-link">react定义组件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-press-blog/react/react/#函数式组件-无状态-state" class="sidebar-link">函数式组件（无状态 state）</a></li><li class="sidebar-sub-header"><a href="/vue-press-blog/react/react/#类式组件-有状态-state" class="sidebar-link">类式组件（有状态 state）</a></li></ul></li><li><a href="/vue-press-blog/react/react/#组件实例的核心属性" class="sidebar-link">组件实例的核心属性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-press-blog/react/react/#state" class="sidebar-link">state</a></li><li class="sidebar-sub-header"><a href="/vue-press-blog/react/react/#props" class="sidebar-link">props</a></li><li class="sidebar-sub-header"><a href="/vue-press-blog/react/react/#refs" class="sidebar-link">refs</a></li><li class="sidebar-sub-header"><a href="/vue-press-blog/react/react/#创建ref" class="sidebar-link">创建ref:</a></li><li class="sidebar-sub-header"><a href="/vue-press-blog/react/react/#ref-转发" class="sidebar-link">ref 转发</a></li></ul></li><li><a href="/vue-press-blog/react/react/#fragment" class="sidebar-link">Fragment</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/react/react/#高阶组件-hoc" class="sidebar-link">高阶组件 Hoc</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/react/react/#jsx-深入" class="sidebar-link">jsx 深入</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/react/react/#portals-将子节点渲染到父组件之外的dom元素" class="sidebar-link">Portals 将子节点渲染到父组件之外的dom元素</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/react/react/#diffing算法" class="sidebar-link">diffing算法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/react/react/#key的作用" class="sidebar-link">key的作用</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/react/react/#react-中的事件处理" class="sidebar-link">react 中的事件处理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/react/react/#函数柯理化" class="sidebar-link">函数柯理化</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/react/react/#生命周期" class="sidebar-link">生命周期</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-press-blog/react/react/#旧版本" class="sidebar-link">旧版本：</a></li><li class="sidebar-sub-header"><a href="/vue-press-blog/react/react/#新版本" class="sidebar-link">新版本：</a></li><li class="sidebar-sub-header"><a href="/vue-press-blog/react/react/#重要的钩子" class="sidebar-link">重要的钩子</a></li></ul></li><li><a href="/vue-press-blog/react/react/#组合继承" class="sidebar-link">组合继承</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/react/react/#diff算法" class="sidebar-link">diff算法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/react/react/#文件" class="sidebar-link">文件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-press-blog/react/react/#样式模块化" class="sidebar-link">样式模块化</a></li></ul></li><li><a href="/vue-press-blog/react/react/#react-插件" class="sidebar-link">react 插件</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/react/react/#todolist-案例" class="sidebar-link">todoList 案例</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/react/react/#组件通信方式" class="sidebar-link">组件通信方式</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/react/react/#react-配置代理" class="sidebar-link">react 配置代理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/react/react/#react-hooks" class="sidebar-link">react hooks</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-press-blog/react/react/#什么是hooks" class="sidebar-link">什么是hooks</a></li><li class="sidebar-sub-header"><a href="/vue-press-blog/react/react/#状态usestate" class="sidebar-link">状态useState()</a></li><li class="sidebar-sub-header"><a href="/vue-press-blog/react/react/#作用effect" class="sidebar-link">作用Effect</a></li></ul></li><li><a href="/vue-press-blog/react/react/#上下文-createcontext" class="sidebar-link">上下文 createContext()</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/react/react/#hooks运行机制" class="sidebar-link">hooks运行机制</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-blog/react/react/#自定义hooks" class="sidebar-link">自定义hooks</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="react特点"><a href="#react特点" class="header-anchor">#</a> react特点</h2> <ol><li>组件化模式，声明式编码</li> <li>在react-native中可以使用react语法进行移动端开发</li> <li>使用虚拟dom+diff 尽量减少真实dom交互</li></ol> <h2 id="react核心文件"><a href="#react核心文件" class="header-anchor">#</a> react核心文件</h2> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;https://unpkg.com/react@18/umd/react.development.js&quot;</span> crossorigin<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span> <span class="token comment">// 核心库 扩展库</span>
 <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;https://unpkg.com/react-dom@18/umd/react-dom.development.js&quot;</span>  crossorigin<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span> <span class="token comment">//操作dom库</span>
 <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span> <span class="token comment">//转换jsx为js ,es6为而es5</span>
</code></pre></div><p>ps: 引入顺序核心库首先引入</p> <h2 id="hello-world"><a href="#hello-world" class="header-anchor">#</a> hello world</h2> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token keyword">const</span> <span class="token constant">VDOM</span> <span class="token operator">=</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>hello react<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span> <span class="token comment">//   1. 创建虚拟dom 这里是jsx语法， </span>
ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token constant">VDOM</span><span class="token punctuation">,</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//2. 渲染虚拟dom</span>
</code></pre></div><h2 id="虚拟dom"><a href="#虚拟dom" class="header-anchor">#</a> 虚拟dom</h2> <ol><li>本质就是Object类型的对象 （一般对象）</li> <li>虚拟dom 熟悉比较少的属性 真实dom 属性很多，因为虚拟dom是react在使用，无需真实dom上面那个多属性</li> <li>虚拟dom 会被react转换为真实dom</li></ol> <h2 id="jsx语法规则"><a href="#jsx语法规则" class="header-anchor">#</a> jsx语法规则</h2> <p>全称： javascript XML</p> <ol><li>不要写语法</li> <li>标签里使用js表达式(会产生一个值)需要使用花括号 {} ，<strong>不可以使用js语句</strong></li> <li>样式类名不能使用class，需要使用classname</li> <li>内联样式style需要使用{ { width:200px } } 第一个括号是代表要使用js语法，第二个表示要使用对象的格式</li> <li>虚拟dom只能有1个根标签</li> <li>标签必须闭合</li> <li>标签首字母
<ul><li>小写字母， 标签改为html标签，html没有就报错</li> <li>大写字母 react渲染对应的组件，找不到报错</li></ul></li></ol> <h2 id="react-18-更新-reactdom-render-以后绑定dom"><a href="#react-18-更新-reactdom-render-以后绑定dom" class="header-anchor">#</a> react 18 更新 ReactDOM.render，以后绑定dom</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// After</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> createRoot <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-dom/client'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> container <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token function">createRoot</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// createRoot(container!) if you use TypeScript</span>
root<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App   <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="react定义组件"><a href="#react定义组件" class="header-anchor">#</a> react定义组件</h2> <h3 id="函数式组件-无状态-state"><a href="#函数式组件-无状态-state" class="header-anchor">#</a> 函数式组件（无状态 state）</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 1. 创建函数式组件</span>
<span class="token keyword">function</span> <span class="token function">Dome</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// this指向：为undefined，因为Babel翻译后会开启严格模式 </span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>h1 className<span class="token operator">=</span><span class="token string">&quot;title&quot;</span><span class="token operator">&gt;</span>我是函数定义的组件适用于简单组件的定义 <span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 2. 渲染组件到页面 </span>
ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>Dome<span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">/* 执行  ReactDOM.render会执行：
1. react先解析组件标签，找到Dome组件，
2. 调用函数，将返回的虚拟dom转为真实dom,呈现页面
*/</span>
</code></pre></div><h4 id="复习js类"><a href="#复习js类" class="header-anchor">#</a> 复习js类</h4> <ol><li>类的构造器不是非必要写的，如需对实例进行初始化操作，如添加属性才写</li> <li>如果A类继承了B类， A中写了构造器， A必须书写super</li> <li>类所定义的方法，都在类的原型上，供实例使用</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
      <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//  this指类的实例</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
      <span class="token punctuation">}</span>
      <span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//类的一般方法，放在类的原型上，给实例使用</span>
        <span class="token comment">//  this指类的实例</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">,</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//继承类 继承Person</span>
    <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
      <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> grade</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token comment">//必须调用哦。顺序必须在最开始</span>
        <span class="token comment">//  this指类的实例</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>grade <span class="token operator">=</span> grade
      <span class="token punctuation">}</span>
      <span class="token comment">//重写父类的方法</span>
      <span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">,</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>grade<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><h3 id="类式组件-有状态-state"><a href="#类式组件-有状态-state" class="header-anchor">#</a> 类式组件（有状态 state）</h3> <ol><li>必须有render函数</li> <li>render函数必须有返回值</li></ol> <div class="language-js extra-class"><pre class="language-js"><code> 
<span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span><span class="token punctuation">{</span><span class="token comment">//React.Component 内置的类</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//可以省略</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
         <span class="token comment">//1. render在类的原型上，供实例使用，给实例使用</span>
        <span class="token comment">// 2. render中this  是MyComponent组件实例对象 props: {}refs: {}state: null</span>
        <span class="token keyword">return</span> <span class="token operator">&lt;</span>h1 className<span class="token operator">=</span><span class="token string">&quot;title&quot;</span><span class="token operator">&gt;</span>我是<span class="token keyword">class</span>定义的组件适用于简单组件的定义 <span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
<span class="token comment">//&lt;MyComponent/&gt; 当书写这个，react会帮助new一个实例</span>
ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>MyComponent<span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">/* 执行  ReactDOM.render(&lt;MyComponent/&gt;...会执行：
1. react先解析组件标签，找到MyComponent组件，
2. &lt;MyComponent/&gt; 当书写这个，react会帮助new一个实例，并通过该实例调用原型上的render方法
2. 将render返回的虚拟dom转为真实dom,呈现页面
*/</span>
</code></pre></div><h2 id="组件实例的核心属性"><a href="#组件实例的核心属性" class="header-anchor">#</a> 组件实例的核心属性</h2> <p>（仅包括类式组件，不包括函数式组件）</p> <h3 id="state"><a href="#state" class="header-anchor">#</a> state</h3> <p>不是state的几种情况：</p> <ul><li><p>该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。</p></li> <li><p>该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。</p></li> <li><p>你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。</p></li> <li><p>setState()修改state状态，只能用这个修改state</p></li> <li><p>更新动作是合并动作不是替换</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Weather</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span><span class="token punctuation">{</span>
     <span class="token comment">/*
         1.更新动作是合并动作不是替换
         2. 构造器只执行一次（constructor）
         3. render方法调用1+n次，n是更新次数
         4. changeHot是点几次调用几次
        */</span> 
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">porps</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>porps<span class="token punctuation">)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
            <span class="token literal-property property">isHot</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token literal-property property">wind</span><span class="token operator">:</span><span class="token string">'微风'</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//改变实例方法调用this为undefined的问题</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>changeHot <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">changeHot</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> <span class="token punctuation">{</span>isHot<span class="token punctuation">,</span>wind<span class="token punctuation">}</span> <span class="token operator">=</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>state 
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>h1 onClick<span class="token operator">=</span><span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>changeHot <span class="token punctuation">}</span><span class="token operator">&gt;</span>今天天气很<span class="token punctuation">{</span> isHot<span class="token operator">?</span><span class="token string">'炎热'</span><span class="token operator">:</span><span class="token string">'寒冷'</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span>wind<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">changeHot</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//this为undefined</span>
        <span class="token comment">// this.state.isHot=!this.state.isHot//错误写法</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">isHot</span><span class="token operator">:</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>isHot<span class="token punctuation">}</span><span class="token punctuation">)</span>
       
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><p>state的简写方式</p> <ul><li>所有在class 定义的组件自定义的方法需要写成：赋值语句+箭头函数（这样是将方法 绑定在实例上，箭头函数中的this不会丢失，指向实哩对象）</li></ul> <h3 id="props"><a href="#props" class="header-anchor">#</a> props</h3> <ul><li>{...props} 传输，从this.props中拿</li> <li>默认值设置，类型设置
ps: react 16版本之后放在了propType.js中拿(之前是放在React.PropTypes中获取)</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 类型设置 给类本身添加</span>
staic propTypes <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span>PropTypes<span class="token punctuation">.</span>string<span class="token punctuation">.</span>isRequired<span class="token comment">//必填</span>
  <span class="token literal-property property">age</span><span class="token operator">:</span>PropTypes<span class="token punctuation">.</span>string
  <span class="token literal-property property">sex</span><span class="token operator">:</span>PropTypes<span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span class="token comment">// 默认值设置</span>
staic defaultProps <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">sex</span><span class="token operator">:</span><span class="token string">'女'</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>props是只读的会报错，只可以运算不可以修改</li> <li>props简写需要将原来定义在类外面的值通过staic关键字用于class内部，给class使用</li></ul> <h4 id="render-props"><a href="#render-props" class="header-anchor">#</a> render props</h4> <p>指一种在react组中使用函数作为props,并且该函数返回一个react元素并调用他，而不是实现他自己的渲染逻辑
render prop 是一个用于告知组件需要渲染什么内容的<strong>函数 prop</strong></p> <h4 id="props函数式组件里面是传递通过参数传递props-默认值和初始值都只写在函数的外面"><a href="#props函数式组件里面是传递通过参数传递props-默认值和初始值都只写在函数的外面" class="header-anchor">#</a> props函数式组件里面是传递通过参数传递props，默认值和初始值都只写在函数的外面</h4> <h3 id="refs"><a href="#refs" class="header-anchor">#</a> refs</h3> <ul><li>字符串形式的ref（最简单）</li> <li>回调形式的ref,参数是这个ref所在的dom节点，内联在jsx中
<ul><li>回调形式的ref，执行次数的问题：
至少执行一次（render时候调用一次）
更新时候会调用两次</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token operator">&lt;</span>input ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">input</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>input1 <span class="token operator">=</span> input<span class="token punctuation">}</span><span class="token punctuation">}</span> type<span class="token operator">=</span><span class="token string">&quot;text&quot;</span> placeholder<span class="token operator">=</span><span class="token string">&quot;点击按钮提示数据&quot;</span><span class="token operator">/</span><span class="token operator">&gt;</span> 
</code></pre></div><ul><li>定义class绑定的函数。只会执行一次</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token operator">&lt;</span>input ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>saveinput<span class="token punctuation">}</span> type<span class="token operator">=</span><span class="token string">&quot;text&quot;</span> placeholder<span class="token operator">=</span><span class="token string">&quot;点击按钮提示数据&quot;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre></div><h3 id="创建ref"><a href="#创建ref" class="header-anchor">#</a> 创建ref:</h3> <p>this.myRef = React.createRef();</p> <p>ref中的current属性在个节点类型中不同的表现</p> <ul><li>ref挂到html中，current为其do元素</li> <li>用于class组件， current为接受组件的挂载实例，例如可以调用封装组件中的方法，属性等。 this.xxxComponent.current.xxx()</li> <li>使用ref传递回调的形式可以在父组件内获取子组件的值
<strong>不可以在函数组件中使用ref,因为函数没有实例</strong></li></ul> <h3 id="ref-转发"><a href="#ref-转发" class="header-anchor">#</a> ref 转发</h3> <p>允许父组件创建ref，并向下传递给自组件，获取子组件的ref
注意点 ： 必须挂在dom元素上，挂在组件上无效</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span><span class="token punctuation">{</span>useRef<span class="token punctuation">,</span>useEffect<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span>
<span class="token comment">//forwardRef 接受的函数的第二个参数即ref</span>
<span class="token keyword">const</span> FancyButton <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">forwardRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> ref</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>input ref<span class="token operator">=</span><span class="token punctuation">{</span>ref<span class="token punctuation">}</span>  <span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">RefLink</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
  <span class="token keyword">const</span> btnref <span class="token operator">=</span>React<span class="token punctuation">.</span><span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//创建一个ref 也可以使用useRef()</span>
  <span class="token keyword">const</span> <span class="token function-variable function">handerclick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    btnref<span class="token punctuation">.</span>current<span class="token operator">?.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">{</span><span class="token comment">/* 将ref通过props传递下去， */</span><span class="token punctuation">}</span>
     <span class="token operator">&lt;</span>FancyButton  ref<span class="token operator">=</span><span class="token punctuation">{</span>btnref<span class="token punctuation">}</span> <span class="token operator">&gt;</span>ref<span class="token operator">&lt;</span><span class="token operator">/</span>FancyButton<span class="token operator">&gt;</span>
     <span class="token operator">&lt;</span>button   onClick<span class="token operator">=</span><span class="token punctuation">{</span>handerclick<span class="token punctuation">}</span> <span class="token operator">&gt;</span> click me<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span>  RefLink
</code></pre></div><h2 id="fragment"><a href="#fragment" class="header-anchor">#</a> Fragment</h2> <p>用于书写根节点的地方
注：在循环中使用需要提供给key, 单标签形式不支持提供props</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token operator">&lt;</span>React<span class="token punctuation">.</span>Fragment<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>td<span class="token operator">&gt;</span>hello<span class="token operator">&lt;</span><span class="token operator">/</span>td<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>td<span class="token operator">&gt;</span>react<span class="token operator">&lt;</span><span class="token operator">/</span>td<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>React<span class="token punctuation">.</span>Fragment<span class="token operator">&gt;</span>
    或者：
     <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>td<span class="token operator">&gt;</span>hello<span class="token operator">&lt;</span><span class="token operator">/</span>td<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>td<span class="token operator">&gt;</span>react<span class="token operator">&lt;</span><span class="token operator">/</span>td<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre></div><h2 id="高阶组件-hoc"><a href="#高阶组件-hoc" class="header-anchor">#</a> 高阶组件 Hoc</h2> <ul><li>纯函数</li> <li>高阶组件是参数为组件，返回值为新组件的函数</li> <li>替换之前的mixin混合代码</li> <li>refs 需要通过 react.forwardRef()函数来进行传递</li></ul> <h2 id="jsx-深入"><a href="#jsx-深入" class="header-anchor">#</a> jsx 深入</h2> <ul><li>React.createElement(component, props, ...children) 函数的语法糖。</li> <li>jsx 可以使用点语法</li> <li>自定义组件必须大写开头</li> <li>自定义组件不能使用表达式</li> <li>props默认值不传为true</li> <li>props可以通过扩展运算符传递</li> <li>标签中间的内容，会作为props.children往下传递（标签航首位的空格以及空行，与标签相邻的空行均会被删除）</li> <li>{showHeader &amp;&amp; <Header></Header>} 仅当 showHeader 为 true 时，才会渲染 <Header></Header> 组件</li></ul> <h2 id="portals-将子节点渲染到父组件之外的dom元素"><a href="#portals-将子节点渲染到父组件之外的dom元素" class="header-anchor">#</a> Portals 将子节点渲染到父组件之外的dom元素</h2> <p>React.createProtal(child,container)
child:任何可渲染的react子元素
container： dom元素
使用案例： 对话框，悬浮卡，提示框</p> <ul><li>protals绑定的元素会冒泡</li></ul> <h2 id="diffing算法"><a href="#diffing算法" class="header-anchor">#</a> diffing算法</h2> <ol><li>比较根节点，根节点不同，直接替换
如：</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>Counter <span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
替换成：
<span class="token operator">&lt;</span>span<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>Counter <span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
React 会销毁 Counter 组件并且重新装载一个新的组件。
</code></pre></div><ol start="2"><li>对比统一类型的元素，保留dom节点，仅对比及更新有改变的属性</li> <li>对比同类型的组件元素 当一个组件更新时，组件实例保持不变，这样 state 在跨越不同的渲染时保持一致。React 将更新该组件实例的 props 以跟最新的元素保持一致，并且调用该实例的 componentWillReceiveProps() 和 componentWillUpdate() 方法。</li></ol> <h2 id="key的作用"><a href="#key的作用" class="header-anchor">#</a> key的作用</h2> <p>主要用于diff算法计算列表的新增和修改时使用，增加性能。
key 不需要全局唯一，但需要在列表中保持唯一</p> <h2 id="react-中的事件处理"><a href="#react-中的事件处理" class="header-anchor">#</a> react 中的事件处理</h2> <ul><li>通过onXxx属性指定时间处理函数
<ul><li>react使用的自定义合成的事件。 并不是原生的dom事件</li> <li>react中的时间是通过事件委托方式处理的，委托给组件最外层的元素， 为了高效</li></ul></li> <li>event.target 获取发生事件的目标元素</li></ul> <h2 id="函数柯理化"><a href="#函数柯理化" class="header-anchor">#</a> 函数柯理化</h2> <ul><li>通过函数调用继续返回函数的方式，实现多次接受参数最后统一处理的函数编码形式</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">saveFormdate</span><span class="token punctuation">(</span><span class="token string">'username'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">//将一个函数给onchange作为回调</span>
 <span class="token function-variable function">saveFormdate</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token parameter">type</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span> 
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span><span class="token comment">//返回的新函数</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
                <span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token operator">:</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value
                <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      
    <span class="token punctuation">}</span>
</code></pre></div><ul><li>高阶函数：
<ul><li>接受的参数是一个函数，</li> <li>调用的返回值是一个函数
常见的高阶函数：</li> <li>promise，setTimeout, arr.map()</li></ul></li></ul> <h2 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h2> <h3 id="旧版本"><a href="#旧版本" class="header-anchor">#</a> 旧版本：</h3> <ul><li>componentWillMount  组件将要被挂载</li> <li>componentDidMount() 在生命周期 组件完成挂载调用 （常用）操作：开启定时器发送网络请求，订阅消息等此方法是服务端渲染唯一会调用的生命周期函数。</li> <li>render() 初始化渲染。状态更新之后（必须要用）</li> <li>shouldComponentUpdate() 组件是否要被更新，控制组件被更新的阀门。必须写返回值：true/false。false表示都不更新</li> <li>componentWillUpdate 组件将要被更新</li> <li>componentDidUpdate(preprops,prestate)) 组件更新完毕 preprops之前的props prestate：之前的state</li> <li>componentWillReceiveProps  组件将要接受新的props时候 第一次不算</li> <li>componentWillUnmount() 组件将要卸载时候掉用（常用）操作： 关闭定时器， 取消订阅消息</li></ul> <h4 id="执行顺序"><a href="#执行顺序" class="header-anchor">#</a> 执行顺序：</h4> <h5 id="挂载时"><a href="#挂载时" class="header-anchor">#</a> 挂载时：</h5> <ol><li>constructor</li> <li>componentWillMount</li> <li>render</li> <li>componentDidMount</li></ol> <h5 id="更新时"><a href="#更新时" class="header-anchor">#</a> 更新时：</h5> <h6 id="setupdate"><a href="#setupdate" class="header-anchor">#</a> setUpdate:</h6> <ol><li>shouldComponentUpdate</li> <li>componentWillUpdate</li> <li>componentDidUpdate</li></ol> <h6 id="foreupdate-强制更新"><a href="#foreupdate-强制更新" class="header-anchor">#</a> foreUpdate() 强制更新</h6> <ol><li>componentWillUpdate</li> <li>componentDidUpdate</li></ol> <h6 id="父组件render-子组件更新"><a href="#父组件render-子组件更新" class="header-anchor">#</a> 父组件render，子组件更新：</h6> <ol><li>componentWillReceiveProps</li> <li>shouldComponentUpdate</li> <li>componentWillUpdate</li> <li>componentDidUpdate</li></ol> <h5 id="卸载时"><a href="#卸载时" class="header-anchor">#</a> 卸载时：</h5> <ol><li>componentWillUnmount</li></ol> <h3 id="新版本"><a href="#新版本" class="header-anchor">#</a> 新版本：</h3> <h4 id="新增"><a href="#新增" class="header-anchor">#</a> 新增：</h4> <ul><li>getDerivedStateFromProps(porps,state) 即 state 的值在任何时候都取决于 props 。特殊情况才使用，了解即可</li> <li>getSnapshotBeforeUpdate(){return :xxx}  更新前获取的快照此用法并不常见，但它可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等。 xxx会传给componentDidUpdate</li></ul> <h4 id="废弃"><a href="#废弃" class="header-anchor">#</a> 废弃：</h4> <ul><li>componentWillMount ==&gt; UNSAFE_componentWillMount</li> <li>componentWillUpdate ==&gt;UNSAFE_componentWillUpdate</li> <li>componentWillReceiveProps ==&gt; UNSAFE_componentWillReceiveProps</li></ul> <h4 id="更新"><a href="#更新" class="header-anchor">#</a> 更新</h4> <p>当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：</p> <ol><li>static getDerivedStateFromProps()</li> <li>shouldComponentUpdate()</li> <li>render()</li> <li>getSnapshotBeforeUpdate()</li> <li>componentDidUpdate(preprops,prestate) preprops之前的props prestate：之前的state</li></ol> <h3 id="重要的钩子"><a href="#重要的钩子" class="header-anchor">#</a> 重要的钩子</h3> <ol><li>render 初始化或者更新渲染时候掉用</li> <li>componentDidMount  开启监听如：ajax</li> <li>componentWillUnmount  即将卸载的钩子</li></ol> <h2 id="组合继承"><a href="#组合继承" class="header-anchor">#</a> 组合继承</h2> <p>props.children 作为插槽插入</p> <h2 id="diff算法"><a href="#diff算法" class="header-anchor">#</a> diff算法</h2> <p>原理：
react进行新虚拟dom和旧虚拟dom的diff比较
比较规则：</p> <ol><li>有相同的key</li> <li>有新的内容直接替换</li> <li>没有新的内容不变</li> <li>没有相同的key</li> <li>直接替换
用index作为key可能会出现的问题</li> <li>当需要对数据进行逆序添加，逆序删除等破坏顺序是修改时会影响格式数据错乱</li> <li>性能更低，需要对虚拟dom进行全部更新</li></ol> <h2 id="文件"><a href="#文件" class="header-anchor">#</a> 文件</h2> <ul><li>src/index.js
入口的js文件<div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 检查app里的东西是否合理</span>
<span class="token operator">&lt;</span>React<span class="token punctuation">.</span>StrictMode<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>React<span class="token punctuation">.</span>StrictMode<span class="token operator">&gt;</span>
</code></pre></div></li> <li>index.html 应用入口文件</li> <li>App.js app组件</li> <li>xxx.jsx 组件名字， 引入时候可以不加后缀 ，如果交index也可以不加，js和jsx都可以不要加</li></ul> <h3 id="样式模块化"><a href="#样式模块化" class="header-anchor">#</a> 样式模块化</h3> <p>文件名：hello.module.css
引入： impoet hello from './index.module.css'</p> <h2 id="react-插件"><a href="#react-插件" class="header-anchor">#</a> react 插件</h2> <p>快速生成react的注解 ES7+ React/Redux/React-</p> <h2 id="todolist-案例"><a href="#todolist-案例" class="header-anchor">#</a> todoList 案例</h2> <ol><li>拆分组件</li> <li>动态初始化列表</li> <li>父子组件通信
<ol><li>父向子： props</li> <li>子向父： 父组件定义一个函数，通过props传递给子组件 子组件通过调用函数传参数的形式修改数据</li></ol></li> <li>checked 和defualtChecked区别 defualtChecked第一次才执行</li> <li>在状态（数据定义的地方）修改状态（定义函数）</li> <li>状态提升：将数据定义在共同的父组件</li></ol> <h2 id="组件通信方式"><a href="#组件通信方式" class="header-anchor">#</a> 组件通信方式</h2> <ul><li>父向子
props</li> <li>子修改父组件的
使用父组件定义函数传递给子组件修改数据,状态在哪里，操作的状态的就在哪里</li></ul> <h2 id="react-配置代理"><a href="#react-配置代理" class="header-anchor">#</a> react 配置代理</h2> <ol><li>在pageage.json中 书写： &quot;proxy&quot;:&quot;http://localtion:3000&quot;</li> <li>src/setupProxy.js配置（webpack自动读取）</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token literal-property property">createProxyMiddleware</span><span class="token operator">:</span> proxy<span class="token punctuation">}</span> <span class="token operator">=</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http-proxy-middleware'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 暴露一个module出去</span>
module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">app</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>
        <span class="token function">proxy</span><span class="token punctuation">(</span><span class="token string">'/api1'</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token comment">//apis遇见这个前缀请求就是会走代理</span>
           <span class="token literal-property property">target</span><span class="token operator">:</span><span class="token string">'http://localhost:5001'</span><span class="token punctuation">,</span>
           <span class="token literal-property property">changeOrigin</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token comment">// 控制服务器收到的请求头host字段的值，让服务器以为是自己的端口发的请求</span>
            <span class="token literal-property property">pathRewrite</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token string-property property">'^/api1'</span><span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token comment">//重写请求路径</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">proxy</span><span class="token punctuation">(</span><span class="token string">'/api2'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>
            <span class="token literal-property property">target</span><span class="token operator">:</span><span class="token string">'http://localhost:5002'</span><span class="token punctuation">,</span>
            <span class="token literal-property property">changeOrigin</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>
            <span class="token literal-property property">pathRewrite</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token string-property property">'^/api2'</span><span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="react-hooks"><a href="#react-hooks" class="header-anchor">#</a> react hooks</h2> <p>状态是什么
状态机：数据 + 改变状态的行为
比如： 点赞数是怎么增加的</p> <h3 id="什么是hooks"><a href="#什么是hooks" class="header-anchor">#</a> 什么是hooks</h3> <p>描述状态后的行为
一个视图，使用了hooks1 hooks2 等</p> <h3 id="状态usestate"><a href="#状态usestate" class="header-anchor">#</a> 状态useState()</h3> <p>精简代码，使用js函数的方式抛弃class</p> <ul><li>useState不能出现在if判断当中</li></ul> <h3 id="作用effect"><a href="#作用effect" class="header-anchor">#</a> 作用Effect</h3> <p>useEffect (deps) 本质是一个函数调用
依赖【变化】变化的作用，如传入state， 就是依赖state数据变化的作用，即每次state更新就会执行，创建一个新的uesEffect函数，如传入空，那么只会执行一次</p> <ul><li>return 的地方会在组件销毁时候关闭</li> <li>useEffect Hook 类是componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数的组合</li> <li>effext 是可选的清除机制，每个effext都可以返回一个清除函数，可以将挂载和移除订阅的逻辑放在玉琪。</li> <li>每个effect都是一个函数逻辑，允许我们按照代码的用途分离他们</li> <li>如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[] ），作为第二个参数。[] 作为第二个参数更接近大家更熟悉的 componentDidMount 和 componentWillUnmount 思维模式</li> <li>React 会等待浏览器完成画面渲染之后才会延迟调用 useEffect</li></ul> <h2 id="上下文-createcontext"><a href="#上下文-createcontext" class="header-anchor">#</a> 上下文 createContext()</h2> <h2 id="hooks运行机制"><a href="#hooks运行机制" class="header-anchor">#</a> hooks运行机制</h2> <ul><li>不要在循环，条件或嵌套函数中调用 Hook，</li></ul> <h2 id="自定义hooks"><a href="#自定义hooks" class="header-anchor">#</a> 自定义hooks</h2> <ul><li>自定义 Hook 必须以 “use” 开头</li> <li>在两个组件中使用相同的 Hook 不会共享 state</li></ul></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/xiaochuanbbd/myBlog-vue-press/edit/master/react/react/README.md" target="_blank" rel="noopener noreferrer">帮助我们改善此页面！</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/vue-press-blog/assets/js/app.af7be2e8.js" defer></script><script src="/vue-press-blog/assets/js/2.b3e5667e.js" defer></script><script src="/vue-press-blog/assets/js/17.29a308e4.js" defer></script>
  </body>
</html>
