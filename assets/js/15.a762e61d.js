(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{437:function(t,_,v){"use strict";v.r(_);var s=v(65),a=Object(s.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"前后端通信"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#前后端通信"}},[t._v("#")]),t._v(" 前后端通信")]),t._v(" "),v("h2",{attrs:{id:"输入url到页面展示"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#输入url到页面展示"}},[t._v("#")]),t._v(" "),v("strong",[t._v("输入url到页面展示")])]),t._v(" "),v("h4",{attrs:{id:"一、域名解析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、域名解析"}},[t._v("#")]),t._v(" 一、域名解析")]),t._v(" "),v("p",[t._v("DNS域名解析从DNS找到对应的IP地址")]),t._v(" "),v("p",[t._v("域名解析步骤：")]),t._v(" "),v("p",[t._v("1.浏览器缓存，缓存包括有协商缓存和强制缓存， 查看是否有缓存：catch-control")]),t._v(" "),v("p",[t._v("​\t触发协商缓存：catch-contorl：no-catch .")]),t._v(" "),v("p",[t._v("​\t协商缓存：eTag,文件有改变会重新请求页面")]),t._v(" "),v("p",[t._v("​\t\t\t\t\t\tlastmodifile 根据文件的修改时间来判断是否重新请求，缺点只能精细到秒")]),t._v(" "),v("p",[t._v("2.本地hosts 浏览器查看本机hosts文件是否有这个IP地址")]),t._v(" "),v("p",[t._v("3.查询本地DNS服务器")]),t._v(" "),v("p",[t._v("4.查询DNS根服务器")]),t._v(" "),v("p",[t._v("5.请求域服务器")]),t._v(" "),v("p",[t._v("6.请求域名解析服务器，到了这一步能收到一个域名和IP地址的对应关系， 此时会讲IP地址缓存到用户电脑，存在缓存中， 以备用户下次访问可以直接放回结果。")]),t._v(" "),v("h4",{attrs:{id:"二、建立tcp连接-三次握手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二、建立tcp连接-三次握手"}},[t._v("#")]),t._v(" 二、建立TCP连接 三次握手")]),t._v(" "),v("p",[t._v("三次握手的目的是为了防止已失效的请求突然又传送到了服务端，从而产生错误")]),t._v(" "),v("p",[v("strong",[t._v("跨域")])]),t._v(" "),v("h4",{attrs:{id:"三、浏览器发送http请求"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三、浏览器发送http请求"}},[t._v("#")]),t._v(" 三、浏览器发送HTTP请求")]),t._v(" "),v("p",[t._v("浏览器会分析url，设置好请求报文发出，HTTP请求端口号是 80 HTTPS请求的端口号是 443")]),t._v(" "),v("p",[t._v("请求报文：")]),t._v(" "),v("p",[t._v("1.请求头 ：请求的方法、路径，协议版本。")]),t._v(" "),v("p",[t._v("2.请求行：请求的附加信息，通常是键值对的行是发送")]),t._v(" "),v("p",[t._v("请求主体 （post请求会放在这里）")]),t._v(" "),v("h4",{attrs:{id:"四、服务器响应http请求"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四、服务器响应http请求"}},[t._v("#")]),t._v(" 四、服务器响应HTTP请求")]),t._v(" "),v("p",[t._v("服务器收到请求后，会根据url匹配到的路径做相应的处理，返回浏览器需要的页面资源。服务器会返回一个响应报文，浏览器收到响应报文")]),t._v(" "),v("p",[t._v("响应报文：")]),t._v(" "),v("p",[t._v("1.响应头：对应请求报文中的请求头")]),t._v(" "),v("p",[t._v("2.响应行：对应请求行，这里不同的是包含响应的状态")]),t._v(" "),v("p",[t._v("3.报文主体：请求返回的资源")]),t._v(" "),v("h4",{attrs:{id:"五、页面渲染"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#五、页面渲染"}},[t._v("#")]),t._v(" 五、页面渲染")]),t._v(" "),v("p",[t._v("1.解析HTML标签，构建DOM树")]),t._v(" "),v("p",[t._v("2.解析CSS标签，构建CSSOM树")]),t._v(" "),v("p",[t._v("3.将DOM和CSSOM组合成渲染树")]),t._v(" "),v("p",[t._v("4.对渲染树进行布局，重排或者回流")]),t._v(" "),v("p",[t._v("5.绘制渲染树 重绘")]),t._v(" "),v("h5",{attrs:{id:"webkit的主要流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#webkit的主要流程"}},[t._v("#")]),t._v(" webkit的主要流程：")]),t._v(" "),v("p",[t._v("1.dom树包含页面全部元素")]),t._v(" "),v("p",[t._v("2.渲染树不等于DOM树，列入header和display元素不用放到渲染树中")]),t._v(" "),v("p",[t._v("3.也页面布局结构发生改变，会发生重排，重排必定会引起重绘")]),t._v(" "),v("p",[t._v("4.与布局无关的样式 只会引起重绘")]),t._v(" "),v("p",[t._v("5.重绘和重排都会影响性能， 重排更消耗性能")]),t._v(" "),v("h5",{attrs:{id:"性能优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[t._v("#")]),t._v(" 性能优化：")]),t._v(" "),v("p",[t._v("使用类名操作样式，而不是使用JS")]),t._v(" "),v("p",[t._v("离线操作display：none==》display：block")]),t._v(" "),v("p",[t._v("频繁操作的元素，例如：动画 可以进行脱靶，开启定位，单独占一行不影响其他元素布局")]),t._v(" "),v("h4",{attrs:{id:"六、tcp四次挥手关闭连接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#六、tcp四次挥手关闭连接"}},[t._v("#")]),t._v(" 六、TCP四次挥手关闭连接")]),t._v(" "),v("h3",{attrs:{id:"http各版本"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http各版本"}},[t._v("#")]),t._v(" "),v("strong",[t._v("HTTP各版本")])]),t._v(" "),v("h4",{attrs:{id:"_1-0版本-1996年"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-0版本-1996年"}},[t._v("#")]),t._v(" 1.0版本（1996年）：")]),t._v(" "),v("p",[t._v("请求行必须在尾部添加协议版本 http/1.0，这个"),v("strong",[t._v("版本每次TCP请求都只能发送一个")]),t._v("请求，当服务器响应后就会关闭这次请求， 下一个请求需要建立TCP 链接，即不支持keepalive")]),t._v(" "),v("h4",{attrs:{id:"_1-1版本-1999年"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-1版本-1999年"}},[t._v("#")]),t._v(" 1.1版本（1999年） ：")]),t._v(" "),v("p",[v("strong",[t._v("引入持久链接")]),t._v("，即TCP链接默认不关闭，可以被多个请求复用 ，一个TCP链接可以允许多个http请求，"),v("strong",[t._v("加入管道机制")]),t._v("，在TCP链接里，允许多个请求同时发送，增加了并发性，进一步改善了HTTP协议的效率")]),t._v(" "),v("h4",{attrs:{id:"_2-0版本"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-0版本"}},[t._v("#")]),t._v(" 2.0版本：")]),t._v(" "),v("p",[v("strong",[t._v("增加双工模式")]),t._v("，即不仅"),v("strong",[t._v("客户端能够同时发送多个请求，服务端也能同时处理多个请")]),t._v("求，解决了堵塞的问题。解决方式是，"),v("em",[t._v("将所有的信息字段建立一张表，为表中的每个字段建立索引，客户端和服务端共同使用这个表。")])]),t._v(" "),v("p",[t._v("提供更多加密支持")]),t._v(" "),v("p",[t._v("增加了头压缩，其请求和相应的header都只会占用很小比例的带宽")]),t._v(" "),v("p",[v("strong",[t._v("HTTPS原理")])]),t._v(" "),v("p",[t._v("HTTPS由两部分组成：http+SSL/TSL.，即在http上又加了一层处理加密信息的模块")]),t._v(" "),v("p",[v("strong",[t._v("对称加密")]),t._v("：加密、解密都是用的一个密钥")]),t._v(" "),v("p",[v("strong",[t._v("非对称加密算法")]),t._v("：公钥和秘钥。公钥是公开钥匙，所有人都可以知道，私钥是私密的，只有持有者知道，公钥进行加密， 私钥进行解密")]),t._v(" "),v("h5",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结：")]),t._v(" "),v("p",[t._v("（一开始"),v("code",[t._v("使用一次非对称加密帮助对称加密的密钥进行传输")]),t._v("， 提高效率）")]),t._v(" "),v("p",[t._v("服务器使用非对称加密生成服务器端公钥和服务器端私钥（只使用一次）")]),t._v(" "),v("p",[t._v("将服务器端公钥放在证书里发送给客户端，服务器端私钥自己保存")]),t._v(" "),v("p",[t._v("客户端向权威服务器检查证书的合法性，如果证书合法，客户端产生一段随机数，随机数就作为通信的的密钥，我们称之为对称密钥，用服务器端公钥加密这段随机数，发送给服务器")]),t._v(" "),v("p",[t._v("服务器用服务器端私钥解密获取对称密钥，然后双方就"),v("strong",[t._v("后续的对称密钥进行加密解密")]),t._v("通信了。")]),t._v(" "),v("h5",{attrs:{id:"http和https的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http和https的区别"}},[t._v("#")]),t._v(" http和https的区别")]),t._v(" "),v("p",[t._v("https协议需要ca证书，费用较高")]),t._v(" "),v("p",[t._v("http没有HTTPS安全系数高，http是明文传输，HTTPS则是具有安全性的ssl和tsl进行加密")]),t._v(" "),v("p",[t._v("http端口号是 80 HTTPS是 443")]),t._v(" "),v("p",[t._v("http是无状态的，并且是明文传输")]),t._v(" "),v("h2",{attrs:{id:"tcp三次握手、四次挥手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp三次握手、四次挥手"}},[t._v("#")]),t._v(" TCP三次握手、四次挥手")]),t._v(" "),v("h4",{attrs:{id:"三次握手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[t._v("#")]),t._v(" 三次握手")]),t._v(" "),v("p",[t._v("第一次握手：建立连接时，客户端发送syn包到服务器，并进入SYN_SENT状态，等待服务器确认。  SYN：同步序列编号")]),t._v(" "),v("p",[t._v("第二次握手：服务器收到syn包，必须确认客户的SYN，同时自己也发送一个SYN包，此时服务器进入SYN_RECV状态")]),t._v(" "),v("p",[t._v("第三次握手：客户端收到服务器的SYN_ACK包，向服务器发送确认包ACK，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手")]),t._v(" "),v("h4",{attrs:{id:"四次挥手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[t._v("#")]),t._v(" 四次挥手")]),t._v(" "),v("p",[t._v("客户端进程发出连接释放报文，并且停止发送数据")]),t._v(" "),v("p",[t._v("服务器收到链接释放报文，发出确认报文，此时服务器进入了CLOSE-WAIT关闭等待状态。")]),t._v(" "),v("p",[t._v("客户端收到服务器的确认请求后客户端进入了终止等待状态，等待服务器发送连接释放报文")]),t._v(" "),v("p",[t._v("服务器将最后的数据发送完毕后，像客户端发送连接释放报文")]),t._v(" "),v("p",[t._v("客户端收到服务器端的连接释放报文后，必须发出确认，此时客户端进入了TIME-WAIT（时间等待）状态")]),t._v(" "),v("p",[t._v("服务器只要收到客户端发出的确认，立即进入CLOSED状态。撤销TCB后，结束了这次TCP连接，服务器结束TCP连接的时间比客户端要早。")]),t._v(" "),v("h2",{attrs:{id:"tcp和udp区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp和udp区别"}},[t._v("#")]),t._v(" TCP和UDP区别")]),t._v(" "),v("p",[t._v("1.基于连接于无连接，UDP是无连接的")]),t._v(" "),v("p",[t._v("2.对系统资源的要求 TCP较多，UDP少")]),t._v(" "),v("p",[t._v("3.UDP程序结构比较简单")]),t._v(" "),v("p",[t._v("4.流模式于数据报模式")]),t._v(" "),v("p",[t._v("5.TCP保证数据正确性， UDP可能会丢包")]),t._v(" "),v("p",[t._v("6.TCP保证数据顺序。UDP不保证")]),t._v(" "),v("h2",{attrs:{id:"http常见状态码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http常见状态码"}},[t._v("#")]),t._v(" HTTP常见状态码")]),t._v(" "),v("p",[t._v("100 通知客户端继续请求")]),t._v(" "),v("p",[t._v("200 表示服务器已接收成功， 并返回了客户端所需要的结果")]),t._v(" "),v("p",[t._v("202 表示服务器已经接受了请求，但是还是没有处理，最终是否处理不确定")]),t._v(" "),v("p",[t._v("204 服务器成功处理了请求，但没有返回任何实体内容，可能会返回新的头部元信息")]),t._v(" "),v("p",[t._v("301 客户端请求的网页已经永久移动到新的位置")]),t._v(" "),v("p",[t._v("304 请求资源是读取的浏览器缓存")]),t._v(" "),v("p",[t._v("404 请求失败，客户端请求的资源没有找到，或者不存在")]),t._v(" "),v("p",[t._v("500 服务器错误")]),t._v(" "),v("p",[t._v("503 服务器是领事服务器，或者是维护")]),t._v(" "),v("h2",{attrs:{id:"鉴权"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#鉴权"}},[t._v("#")]),t._v(" 鉴权")]),t._v(" "),v("p",[v("strong",[t._v("鉴权是指验证用户是否拥有访问系统的权利")])]),t._v(" "),v("h4",{attrs:{id:"鉴权分类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#鉴权分类"}},[t._v("#")]),t._v(" 鉴权分类：")]),t._v(" "),v("p",[t._v("用户鉴权。网络对用户进行鉴权，防止非法用户占用网络资源")]),t._v(" "),v("p",[t._v("网络鉴权.用户对网络进行鉴权，防止用户及接入了非法的网络，被骗取关键信息")]),t._v(" "),v("h4",{attrs:{id:"常用的鉴权方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常用的鉴权方式"}},[t._v("#")]),t._v(" 常用的鉴权方式：")]),t._v(" "),v("h4",{attrs:{id:"_1-http-basic-anthentication"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-http-basic-anthentication"}},[t._v("#")]),t._v(" 1.HTTP Basic Anthentication")]),t._v(" "),v("h4",{attrs:{id:"_2-session-cookie"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-session-cookie"}},[t._v("#")]),t._v(" 2.session-cookie")]),t._v(" "),v("p",[t._v("服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向服务器在发起请求时被携带并发送到服务器上。")]),t._v(" "),v("h5",{attrs:{id:"cookie主要应用于"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cookie主要应用于"}},[t._v("#")]),t._v(" cookie主要应用于：")]),t._v(" "),v("p",[t._v("会话状态管理（用户登录状态，购物车， 游戏分数，或者需要记录的其他信息）")]),t._v(" "),v("p",[t._v("个性化设置（比如用户自定义设置，比如主体）")]),t._v(" "),v("p",[t._v("浏览器跟踪行为，如跟踪分析用户行为等")]),t._v(" "),v("h4",{attrs:{id:"sesston-cookie和token的性能对比"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#sesston-cookie和token的性能对比"}},[t._v("#")]),t._v(" sesston-cookie和token的性能对比")]),t._v(" "),v("p",[v("strong",[t._v("判定合规的流程：")]),t._v(" sessionid他是一个唯一标识的字符串，服务端根据这个字符串，来查询服务端保持的session，这儿里面保存着用户的登录状态，而token本身就是一种登录成功凭证，他是在登录成功之后根据某种规则生成的一种信息凭证，服务器只需要判断这个token是否合规就行。")]),t._v(" "),v("p",[t._v("**客户端的限制性：**session-cookie是需要cookie配合的，那么http代理的客户端选择就只有浏览器，只有浏览器才会去解析coolie， cookie-session限制了他的客户端类型只有浏览器。不适用于原生APP等等，而token是可以存在cookie或者本地或者内存中，这种机制丰富了客户端的类型")]),t._v(" "),v("p",[t._v("**时效性：**session-cookie一经登录成功后到退出时是一直不变的， token会一段时间内动态改变")]),t._v(" "),v("p",[t._v("**可扩展性:**token比较灵活，解决token的解决方案很多，常用的是JWT，也可以基于token的鉴权系统专门做一个鉴权服务， 用它向多个服务的请求进行统一鉴权")]),t._v(" "),v("h4",{attrs:{id:"session和cookie的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#session和cookie的区别"}},[t._v("#")]),t._v(" session和cookie的区别")]),t._v(" "),v("p",[t._v("1.session存放在服务器，大小没有限制，会占用服务器过多的内存，比cookie安全，session依赖于cookie，在cookie里存储一个sessionid")]),t._v(" "),v("p",[t._v("2.cookie 服务器生成，可以设置失效时间， 大小大概4kb，没有session安全，通过http设置请求头带过去")]),t._v(" "),v("h4",{attrs:{id:"_3-token验证"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-token验证"}},[t._v("#")]),t._v(" 3.Token验证")]),t._v(" "),v("p",[t._v("1.用户输入密码和用户名")]),t._v(" "),v("p",[t._v("2.服务器验证用户密码用户名是否正确， 返回经过签名的token")]),t._v(" "),v("p",[t._v("3.客户端保存服务端返回的token，存储在cookie或者localstorage中")]),t._v(" "),v("p",[t._v("4.客户端请求时带上这个token")]),t._v(" "),v("p",[t._v("5.服务端通过JWT进行解码，判断这个token是否有效。有效就处理该请求")]),t._v(" "),v("p",[t._v("6.用户退出登录时清除token，同时清除cookie或者localstorage里的token")]),t._v(" "),v("p",[t._v("4.OAuth 开放授权")]),t._v(" "),v("h2",{attrs:{id:"重排、重绘"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#重排、重绘"}},[t._v("#")]),t._v(" 重排、重绘")]),t._v(" "),v("p",[v("strong",[t._v("重排一定会产生重绘，重绘不一定产生重排")])]),t._v(" "),v("p",[v("strong",[t._v("引起重排的情况")]),t._v("：")]),t._v(" "),v("p",[t._v("1.页面首次渲染")]),t._v(" "),v("p",[t._v("2.浏览器窗口尺寸发生变化")]),t._v(" "),v("p",[t._v("3.新增和删除可见元素")]),t._v(" "),v("p",[t._v("4.元素位置和尺寸，字体大小发生变化")]),t._v(" "),v("p",[t._v("5.css伪类激活 如hover")]),t._v(" "),v("p",[t._v("6.设置style属性")]),t._v(" "),v("p",[v("strong",[t._v("引起重绘的情况")]),t._v("：")]),t._v(" "),v("p",[t._v("1.字体的颜色，背景色")]),t._v(" "),v("p",[t._v("只改变颜色外观等不改变布局的情况")]),t._v(" "),v("h1",{attrs:{id:"浏览器兼容"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器兼容"}},[t._v("#")]),t._v(" 浏览器兼容")]),t._v(" "),v("h3",{attrs:{id:"产生原因"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#产生原因"}},[t._v("#")]),t._v(" 产生原因：")]),t._v(" "),v("p",[t._v("市面上的浏览器总类很多，但由于不同的浏览器内核不一样，从而导致浏览器对网页的解析产生差异")]),t._v(" "),v("h2",{attrs:{id:"js兼容"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#js兼容"}},[t._v("#")]),t._v(" js兼容")]),t._v(" "),v("p",[t._v("几个例子：")]),t._v(" "),v("h4",{attrs:{id:"一、阻止冒泡"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、阻止冒泡"}},[t._v("#")]),t._v(" 一、阻止冒泡")]),t._v(" "),v("p",[t._v("IE :event.cancelBubble  = true")]),t._v(" "),v("p",[t._v("chorme： event.stopPropagation()")]),t._v(" "),v("h4",{attrs:{id:"二、兼容鼠标事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二、兼容鼠标事件"}},[t._v("#")]),t._v(" 二、兼容鼠标事件")]),t._v(" "),v("p",[t._v("var key  = e.keyCode || e.charCode|| e.which")]),t._v(" "),v("h4",{attrs:{id:"三、阻止超链接默认行为"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三、阻止超链接默认行为"}},[t._v("#")]),t._v(" 三、阻止超链接默认行为")]),t._v(" "),v("p",[t._v("e.preventDefault? e.preventDefault(): e.returnValue = false")]),t._v(" "),v("h4",{attrs:{id:"四、事件target的获取"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四、事件target的获取"}},[t._v("#")]),t._v(" 四、事件target的获取")]),t._v(" "),v("p",[t._v("ie： e.srcElement")]),t._v(" "),v("p",[t._v("chorme : e.target")]),t._v(" "),v("h2",{attrs:{id:"css兼容"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#css兼容"}},[t._v("#")]),t._v(" css兼容")]),t._v(" "),v("h5",{attrs:{id:"一、不同浏览器的标签默认的margin和padding值不用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、不同浏览器的标签默认的margin和padding值不用"}},[t._v("#")]),t._v(" 一、不同浏览器的标签默认的margin和padding值不用")]),t._v(" "),v("p",[t._v("解决办法： css里使用 * 设置margin：0.padding：0")]),t._v(" "),v("h4",{attrs:{id:"二、图片默认有间距"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二、图片默认有间距"}},[t._v("#")]),t._v(" 二、图片默认有间距")]),t._v(" "),v("p",[t._v("问题：几个img标签放在一起，有些浏览器会有默认的间距，有通配符也不起作用")]),t._v(" "),v("p",[t._v("解决办法：使用display：flex布局")]),t._v(" "),v("h4",{attrs:{id:"三、css-hack"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三、css-hack"}},[t._v("#")]),t._v(" 三、css hack")]),t._v(" "),v("p",[t._v("通过在css样式中加入一些特殊的符号，让不同的浏览器识别不同的符号。 什么样的浏览器识别什么样的符号是有标准的，css hack就是做这个标准。达到应用不同的css样式的目的。")]),t._v(" "),v("p",[t._v("css hack 表现前缀：")]),t._v(" "),v("ol",[v("li",[t._v("CSS属性前缀法")]),t._v(" "),v("li",[t._v("选择器前缀法")]),t._v(" "),v("li",[t._v("IE条件注释发")])]),t._v(" "),v("h4",{attrs:{id:"四、工程化-postcss"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四、工程化-postcss"}},[t._v("#")]),t._v(" 四、工程化 postcss")]),t._v(" "),v("p",[t._v("会自动对各浏览器进行兼容，自动添加上适配各个浏览器的css前缀")]),t._v(" "),v("h4",{attrs:{id:"五、兼容性思想"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#五、兼容性思想"}},[t._v("#")]),t._v(" 五、兼容性思想")]),t._v(" "),v("h6",{attrs:{id:"渐进增强-先兼容低版本浏览器-在对高版本浏览器进行高级交互"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#渐进增强-先兼容低版本浏览器-在对高版本浏览器进行高级交互"}},[t._v("#")]),t._v(" 渐进增强 ：先兼容低版本浏览器，在对高版本浏览器进行高级交互")]),t._v(" "),v("h6",{attrs:{id:"优雅降级-先针对高级浏览器的css-再对特殊浏览器进行处理。比如圆角识别不出来-使用图片"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优雅降级-先针对高级浏览器的css-再对特殊浏览器进行处理。比如圆角识别不出来-使用图片"}},[t._v("#")]),t._v(" 优雅降级：先针对高级浏览器的css，再对特殊浏览器进行处理。比如圆角识别不出来 使用图片")]),t._v(" "),v("p",[t._v("话术：css兼容我具体做到的 是 *设值margin和padding，了解到的有css hack，css hack主要是针对各大浏览器和各版本书写不同的css，比如给属性和选择器添加前缀。css兼容有两种思想。。。 我们项目中主要是做工程化配置的postcss 来做")]),t._v(" "),v("h2",{attrs:{id:"pc兼容移动端"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#pc兼容移动端"}},[t._v("#")]),t._v(" pc兼容移动端")]),t._v(" "),v("h4",{attrs:{id:"_1-viewport适配-开启理想视口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-viewport适配-开启理想视口"}},[t._v("#")]),t._v(" 1.viewport适配，开启理想视口")]),t._v(" "),v("meta",{attrs:{name:"viewport",content:"width=device-width,user-scalable=no,initial-scale=1.0,  maximum-scale=1.0,minimum-scale=1.0"}}),t._v(" "),v("p",[t._v("方法：设置布局视口宽读为设计稿宽度，直接按照设计稿给的宽度进行布局即可")]),t._v(" "),v("p",[t._v("优点： 不用复杂的计算，直接使用图稿上标注的PX值就行")]),t._v(" "),v("p",[t._v("缺点：")]),t._v(" "),v("ul",[v("li",[t._v("不能使用完整的meta标签， 会导致在某些安卓手机上有兼容性问题")]),t._v(" "),v("li",[t._v("不希望适配的东西，例如边框，也参与了适配")]),t._v(" "),v("li",[t._v("图片会失真")])]),t._v(" "),v("h4",{attrs:{id:"_2-使用rem设置根字体大小"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-使用rem设置根字体大小"}},[t._v("#")]),t._v(" 2.使用rem设置根字体大小")]),t._v(" "),v("p",[t._v("em,rem, css中的长度单位，两个都是相对长度单位，em是相对于父元素， rem是相对根元素的字体大小")]),t._v(" "),v("p",[t._v("适配原理： 编写样式时统一使用rem为单位，在不同设备商动态调整根字体大小")]),t._v(" "),v("p",[t._v("具体使用案例：淘宝 手淘")]),t._v(" "),v("p",[t._v("通过js设置根字体大小 ：当前设备横向独立像素值 *100 /设计稿宽度")]),t._v(" "),v("p",[t._v("编写样式时： 移动端：rem作为css单位，设计稿的值/100")]),t._v(" "),v("p",[t._v("优点： 编写样式时直接挪动小数点就可以")]),t._v(" "),v("p",[t._v("缺点：必须通过一段js代码控制font-size的大小， 这段代码还必须在页面第一次加载完成。并且放在引入css样式代码之前")]),t._v(" "),v("h4",{attrs:{id:"_3-媒体查询"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-媒体查询"}},[t._v("#")]),t._v(" 3.媒体查询")]),t._v(" "),v("p",[t._v("为不同的媒体设置不同的css样式。")]),t._v(" "),v("h4",{attrs:{id:"_4-vw适配"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-vw适配"}},[t._v("#")]),t._v(" 4.vw适配")]),t._v(" "),v("p",[t._v("vw是相对于布局视口宽度的  1vh = 布局视口宽度的 1%")]),t._v(" "),v("p",[t._v("vh是相对于布局视口宽度 1vh=布局视口高度的 1%")]),t._v(" "),v("p",[t._v("插件==》postcss-px-to-viewport 我们项目中是用的这个")])])}),[],!1,null,null,null);_.default=a.exports}}]);