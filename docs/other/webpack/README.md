 
## plugins和loader有什么区别

loader是解析规则， webpack是解析的js，所以loader里面需要配置一些规则（rules）

plugins是插件，是用来扩展webpack的功能的，比如压缩代码，提取公共组件

## 输出文件名的hash、chunkhash和contenthash有什么区别？

hash： 只要又该一个文件，整个项目的文件命名都会被修改，不能进行缓存

chunkhash：根据入口文件命名，单独打包公共库和程序入口文件，只要不变动公共库的文件就可以保证hash值不会受到影响。线上的时候只要文件内容没有更改就不会重复构建

contenthash：根据内容生成命名，进行缓存



## polifill

中文翻译是腻子，实际上就是针对各个浏览器的js差异做出抹平处理，比如说html5的localstorage和sessionstorage，不同浏览器不同版本支持情况不一样，这个时候可以使用polifill把这些差异抹平

## 什么是treeshaking

树摇 删除多余冗余的代码

## webpack  externals是做什么的

不想把某个东西打包出来，可以使用externals。转为cdn 引入

功能：压缩工程大小。 比如百度地图和echars图标我们可以使用此方式配置

```
externals: {
       mathTools: "tools"
     },
```

## babel

将es6语法转为es5：先将js代码转为AST语法树，在根据语法树，生成es5代码

## vite和webpack的对比

### webpack打包过程：

1.识别入口文件

2.通过逐层识别模块依赖

3.分析代码，转换代码。编译代码，输出代码

4.最终形成打包后的代码

### webpack打包原理：

1. 逐层递归识别依赖，构建依赖图谱
2. 将代码转换为AST树抽象语法树
3. 在AST阶段中去处理代码
4. 吧AST抽象语法树变成浏览器可以识别的代码

### vite原理：

1. 当声明一个script标签类型为module时
2. 浏览器会像服务器发起一个get请求
3. 浏览器请求到了main。js文件，检测到内部含有import引入的包，又会对其内部的import应用发起HTTP请求获取模块的内容文件

### vite的主要功能：

劫持浏览器的请求，并在后端进行相应的处理将项目中使用的文件通过简单的分解和整合，然后返回给浏览器，vite整个过程并没有对文件进行打包编译，所以运行速度比webpack编译速度要快很多

### webpack缺点：

1.冷启动开发服务器时，webpack是在提供服务前急切的去抓取和构建整个应用

vite改进：

- 将应用的模块分为‘’依赖‘’和‘’源码‘’两类。改进了开发服务器启动时间
- 依赖会被拆分到大量小模块中
- 会使用esbuild预构建依赖，esbuild使用GO编写，比以js编写的打包器与构建依赖块10-100倍
- 以原生ESM方式服务源码，实际上是浏览器接管打包程序的部分工作，vite只需要在浏览器请求源码时，进行转换并按需提供源码。

2.使用node.js去实现

vite使用的是esbuild预构建依赖， 使用go语言。

3.热更新效率低下

  打包器启动后，编辑文件即重新构建文件本身，重构整个包。，及时使用HMR更新速度也会随着应用规模的增长而显著下降

vite改进：

- vite中的HRM是原生ESM上去执行的， 当编辑一个文件，vite只需要精准的使已编辑的模块与其最近的HMR边界之间的链失效。使HMR更新始终快速，无论应用大小
- 同时利用HTTP头来加速页面重新加载， 源码模块请求会根据 304进行写上缓存。 依赖模块则会通过cache-contorl：max-age= XXX强制缓存， 因此一旦被缓存它们将不需再次请求

### vite缺点

生态，没有webpack那么多plugins和loader

