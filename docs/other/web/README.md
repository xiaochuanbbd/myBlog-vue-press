## 前后端通信

## **输入url到页面展示**

#### 一、域名解析

DNS域名解析从DNS找到对应的IP地址

域名解析步骤：

1.浏览器缓存，缓存包括有协商缓存和强制缓存， 查看是否有缓存：catch-control

​	触发协商缓存：catch-contorl：no-catch .

​	协商缓存：eTag,文件有改变会重新请求页面

​						lastmodifile 根据文件的修改时间来判断是否重新请求，缺点只能精细到秒

2.本地hosts 浏览器查看本机hosts文件是否有这个IP地址

3.查询本地DNS服务器

4.查询DNS根服务器

5.请求域服务器

6.请求域名解析服务器，到了这一步能收到一个域名和IP地址的对应关系， 此时会讲IP地址缓存到用户电脑，存在缓存中， 以备用户下次访问可以直接放回结果。

#### 二、建立TCP连接 三次握手

三次握手的目的是为了防止已失效的请求突然又传送到了服务端，从而产生错误

**跨域**

#### 三、浏览器发送HTTP请求

浏览器会分析url，设置好请求报文发出，HTTP请求端口号是 80 HTTPS请求的端口号是 443

请求报文：

1.请求头 ：请求的方法、路径，协议版本。

2.请求行：请求的附加信息，通常是键值对的行是发送

请求主体 （post请求会放在这里）

#### 四、服务器响应HTTP请求

服务器收到请求后，会根据url匹配到的路径做相应的处理，返回浏览器需要的页面资源。服务器会返回一个响应报文，浏览器收到响应报文

响应报文：

1.响应头：对应请求报文中的请求头

2.响应行：对应请求行，这里不同的是包含响应的状态

3.报文主体：请求返回的资源

#### 五、页面渲染

1.解析HTML标签，构建DOM树

2.解析CSS标签，构建CSSOM树

3.将DOM和CSSOM组合成渲染树

4.对渲染树进行布局，重排或者回流

5.绘制渲染树 重绘

##### webkit的主要流程：

1.dom树包含页面全部元素

2.渲染树不等于DOM树，列入header和display元素不用放到渲染树中

3.也页面布局结构发生改变，会发生重排，重排必定会引起重绘

4.与布局无关的样式 只会引起重绘

5.重绘和重排都会影响性能， 重排更消耗性能

##### 性能优化：

使用类名操作样式，而不是使用JS

离线操作display：none==》display：block

频繁操作的元素，例如：动画 可以进行脱靶，开启定位，单独占一行不影响其他元素布局

#### 六、TCP四次挥手关闭连接

### **HTTP各版本**

#### 1.0版本（1996年）：

请求行必须在尾部添加协议版本 http/1.0，这个**版本每次TCP请求都只能发送一个**请求，当服务器响应后就会关闭这次请求， 下一个请求需要建立TCP 链接，即不支持keepalive

#### 1.1版本（1999年） ：

**引入持久链接**，即TCP链接默认不关闭，可以被多个请求复用 ，一个TCP链接可以允许多个http请求，**加入管道机制**，在TCP链接里，允许多个请求同时发送，增加了并发性，进一步改善了HTTP协议的效率 

#### 2.0版本：

**增加双工模式**，即不仅**客户端能够同时发送多个请求，服务端也能同时处理多个请**求，解决了堵塞的问题。解决方式是，*将所有的信息字段建立一张表，为表中的每个字段建立索引，客户端和服务端共同使用这个表。*

提供更多加密支持

增加了头压缩，其请求和相应的header都只会占用很小比例的带宽





**HTTPS原理**

HTTPS由两部分组成：http+SSL/TSL.，即在http上又加了一层处理加密信息的模块

**对称加密**：加密、解密都是用的一个密钥

**非对称加密算法**：公钥和秘钥。公钥是公开钥匙，所有人都可以知道，私钥是私密的，只有持有者知道，公钥进行加密， 私钥进行解密

##### 总结：

（一开始`使用一次非对称加密帮助对称加密的密钥进行传输`， 提高效率）

服务器使用非对称加密生成服务器端公钥和服务器端私钥（只使用一次）

将服务器端公钥放在证书里发送给客户端，服务器端私钥自己保存

客户端向权威服务器检查证书的合法性，如果证书合法，客户端产生一段随机数，随机数就作为通信的的密钥，我们称之为对称密钥，用服务器端公钥加密这段随机数，发送给服务器

服务器用服务器端私钥解密获取对称密钥，然后双方就**后续的对称密钥进行加密解密**通信了。

##### http和https的区别

https协议需要ca证书，费用较高

http没有HTTPS安全系数高，http是明文传输，HTTPS则是具有安全性的ssl和tsl进行加密

http端口号是 80 HTTPS是 443

http是无状态的，并且是明文传输



## TCP三次握手、四次挥手

#### 三次握手

第一次握手：建立连接时，客户端发送syn包到服务器，并进入SYN_SENT状态，等待服务器确认。  SYN：同步序列编号

第二次握手：服务器收到syn包，必须确认客户的SYN，同时自己也发送一个SYN包，此时服务器进入SYN_RECV状态

第三次握手：客户端收到服务器的SYN_ACK包，向服务器发送确认包ACK，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手

#### 四次挥手

客户端进程发出连接释放报文，并且停止发送数据

服务器收到链接释放报文，发出确认报文，此时服务器进入了CLOSE-WAIT关闭等待状态。

客户端收到服务器的确认请求后客户端进入了终止等待状态，等待服务器发送连接释放报文

服务器将最后的数据发送完毕后，像客户端发送连接释放报文

客户端收到服务器端的连接释放报文后，必须发出确认，此时客户端进入了TIME-WAIT（时间等待）状态

服务器只要收到客户端发出的确认，立即进入CLOSED状态。撤销TCB后，结束了这次TCP连接，服务器结束TCP连接的时间比客户端要早。

## TCP和UDP区别

1.基于连接于无连接，UDP是无连接的

2.对系统资源的要求 TCP较多，UDP少

3.UDP程序结构比较简单

4.流模式于数据报模式

5.TCP保证数据正确性， UDP可能会丢包

6.TCP保证数据顺序。UDP不保证



## HTTP常见状态码

100 通知客户端继续请求

200 表示服务器已接收成功， 并返回了客户端所需要的结果

202 表示服务器已经接受了请求，但是还是没有处理，最终是否处理不确定

204 服务器成功处理了请求，但没有返回任何实体内容，可能会返回新的头部元信息

301 客户端请求的网页已经永久移动到新的位置 

304 请求资源是读取的浏览器缓存

404 请求失败，客户端请求的资源没有找到，或者不存在

500 服务器错误

503 服务器是领事服务器，或者是维护



## 鉴权

**鉴权是指验证用户是否拥有访问系统的权利**

#### 鉴权分类：

用户鉴权。网络对用户进行鉴权，防止非法用户占用网络资源

网络鉴权.用户对网络进行鉴权，防止用户及接入了非法的网络，被骗取关键信息

#### 常用的鉴权方式：

#### 1.HTTP Basic Anthentication

#### 2.session-cookie

服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向服务器在发起请求时被携带并发送到服务器上。

##### cookie主要应用于：

 会话状态管理（用户登录状态，购物车， 游戏分数，或者需要记录的其他信息）

个性化设置（比如用户自定义设置，比如主体）

浏览器跟踪行为，如跟踪分析用户行为等

#### sesston-cookie和token的性能对比 

**判定合规的流程：** sessionid他是一个唯一标识的字符串，服务端根据这个字符串，来查询服务端保持的session，这儿里面保存着用户的登录状态，而token本身就是一种登录成功凭证，他是在登录成功之后根据某种规则生成的一种信息凭证，服务器只需要判断这个token是否合规就行。

**客户端的限制性：**session-cookie是需要cookie配合的，那么http代理的客户端选择就只有浏览器，只有浏览器才会去解析coolie， cookie-session限制了他的客户端类型只有浏览器。不适用于原生APP等等，而token是可以存在cookie或者本地或者内存中，这种机制丰富了客户端的类型

**时效性：**session-cookie一经登录成功后到退出时是一直不变的， token会一段时间内动态改变

**可扩展性:**token比较灵活，解决token的解决方案很多，常用的是JWT，也可以基于token的鉴权系统专门做一个鉴权服务， 用它向多个服务的请求进行统一鉴权

#### session和cookie的区别

1.session存放在服务器，大小没有限制，会占用服务器过多的内存，比cookie安全，session依赖于cookie，在cookie里存储一个sessionid

2.cookie 服务器生成，可以设置失效时间， 大小大概4kb，没有session安全，通过http设置请求头带过去

#### 3.Token验证

1.用户输入密码和用户名

2.服务器验证用户密码用户名是否正确， 返回经过签名的token

3.客户端保存服务端返回的token，存储在cookie或者localstorage中

4.客户端请求时带上这个token

5.服务端通过JWT进行解码，判断这个token是否有效。有效就处理该请求

6.用户退出登录时清除token，同时清除cookie或者localstorage里的token

4.OAuth 开放授权



## 重排、重绘

**重排一定会产生重绘，重绘不一定产生重排**

**引起重排的情况**：

1.页面首次渲染

2.浏览器窗口尺寸发生变化

3.新增和删除可见元素

4.元素位置和尺寸，字体大小发生变化

5.css伪类激活 如hover

6.设置style属性

**引起重绘的情况**：

1.字体的颜色，背景色

只改变颜色外观等不改变布局的情况
# 浏览器兼容

### 产生原因： 

市面上的浏览器总类很多，但由于不同的浏览器内核不一样，从而导致浏览器对网页的解析产生差异

## js兼容

几个例子：

#### 一、阻止冒泡

 IE :event.cancelBubble  = true

chorme： event.stopPropagation()

#### 二、兼容鼠标事件

var key  = e.keyCode || e.charCode|| e.which

#### 三、阻止超链接默认行为

e.preventDefault? e.preventDefault(): e.returnValue = false

#### 四、事件target的获取

ie： e.srcElement

chorme : e.target

## css兼容

##### 一、不同浏览器的标签默认的margin和padding值不用

解决办法： css里使用 * 设置margin：0.padding：0 

#### 二、图片默认有间距

问题：几个img标签放在一起，有些浏览器会有默认的间距，有通配符也不起作用 

解决办法：使用display：flex布局

#### 三、css hack

通过在css样式中加入一些特殊的符号，让不同的浏览器识别不同的符号。 什么样的浏览器识别什么样的符号是有标准的，css hack就是做这个标准。达到应用不同的css样式的目的。

css hack 表现前缀：

1. CSS属性前缀法
2. 选择器前缀法
3. IE条件注释发

#### 四、工程化 postcss

会自动对各浏览器进行兼容，自动添加上适配各个浏览器的css前缀

#### 五、兼容性思想 

###### 渐进增强 ：先兼容低版本浏览器，在对高版本浏览器进行高级交互

###### 优雅降级：先针对高级浏览器的css，再对特殊浏览器进行处理。比如圆角识别不出来 使用图片

话术：css兼容我具体做到的 是 *设值margin和padding，了解到的有css hack，css hack主要是针对各大浏览器和各版本书写不同的css，比如给属性和选择器添加前缀。css兼容有两种思想。。。 我们项目中主要是做工程化配置的postcss 来做

## pc兼容移动端

#### 1.viewport适配，开启理想视口

 <meta name="viewport"content="width=device-width,user-scalable=no,initial-scale=1.0,  maximum-scale=1.0,minimum-scale=1.0">	


方法：设置布局视口宽读为设计稿宽度，直接按照设计稿给的宽度进行布局即可

优点： 不用复杂的计算，直接使用图稿上标注的PX值就行

缺点：

- 不能使用完整的meta标签， 会导致在某些安卓手机上有兼容性问题
- 不希望适配的东西，例如边框，也参与了适配
- 图片会失真

#### 2.使用rem设置根字体大小

 em,rem, css中的长度单位，两个都是相对长度单位，em是相对于父元素， rem是相对根元素的字体大小 

适配原理： 编写样式时统一使用rem为单位，在不同设备商动态调整根字体大小

具体使用案例：淘宝 手淘

通过js设置根字体大小 ：当前设备横向独立像素值 *100 /设计稿宽度

编写样式时： 移动端：rem作为css单位，设计稿的值/100

优点： 编写样式时直接挪动小数点就可以

缺点：必须通过一段js代码控制font-size的大小， 这段代码还必须在页面第一次加载完成。并且放在引入css样式代码之前

#### 3.媒体查询

为不同的媒体设置不同的css样式。

#### 4.vw适配

vw是相对于布局视口宽度的  1vh = 布局视口宽度的 1%

vh是相对于布局视口宽度 1vh=布局视口高度的 1%

插件==》postcss-px-to-viewport 我们项目中是用的这个






